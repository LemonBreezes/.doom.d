#+TITLE: My Doom Emacs config
#+AUTHOR: Antonio Ruiz
* Table of Contents :TOC:noexport:
- [[#preamble][Preamble]]
  - [[#enable-lexical-scoping][Enable lexical scoping]]
  - [[#speed-up-garbage-collection-in-exchange-for-increased-memory-usage][Speed up garbage collection in exchange for increased memory usage]]
  - [[#use-cache-for-font-utils][Use cache for font-utils]]
  - [[#set-default-fonts][Set default fonts]]
  - [[#set-default-web-browser][Set default web browser]]
  - [[#set-source-directory][Set source directory]]
  - [[#disable-suspend-frame-outside-of-terminal][Disable suspend frame outside of terminal]]
  - [[#set-up-calendar-the-package-calendar][Set up calendar (the package calendar)]]
  - [[#set-up-email-address--full-name][Set up email address & full name]]
  - [[#recent-files-configuration][Recent files configuration]]
  - [[#set-default-printer][Set default printer]]
  - [[#use-relative-line-numbers][Use relative line numbers]]
  - [[#add-startpage-as-search-provider][Add startpage as search provider]]
  - [[#turn-off-shift-selection][Turn off shift selection]]
  - [[#disable-modeline-force-update-does-this-improve-performance][Disable modeline force update (does this improve performance?)]]
  - [[#enable-transparent-encryptiondecryption-of-files][Enable transparent encryption/decryption of files]]
  - [[#emacs-libjit][Emacs-Libjit]]
- [[#personal-modules][Personal modules]]
  - [[#translation-layer-for-my-keyboard-layout][Translation layer for my keyboard layout]]
  - [[#hippie-expand][Hippie expand]]
  - [[#visual-scrolling][Visual scrolling]]
  - [[#copy-a-defun-for-reddit][Copy a defun for Reddit]]
  - [[#basic-keybindings][Basic keybindings]]
  - [[#filter-echo-area-messages][Filter echo area messages]]
  - [[#emacs-application-framework][Emacs Application Framework]]
  - [[#exwm][EXWM]]
  - [[#modeline-in-echo-area][Modeline in echo area]]
  - [[#replace-text-visually][Replace text visually]]
  - [[#indent-aggressively][Indent aggressively]]
  - [[#show-matching-parens-even-when-offscreen][Show matching parens even when offscreen]]
  - [[#save-buffers-upon-switching-focus][Save buffers upon switching focus]]
  - [[#fontify-page-break-characters][Fontify page-break characters]]
  - [[#isearch-configuration][Isearch configuration]]
  - [[#avy-configuration][Avy configuration]]
  - [[#info-mode-configuration][Info mode configuration]]
  - [[#ace-window-configuration][Ace window configuration]]
  - [[#display-eldoc-hint-in-child-frame-at-point][Display eldoc hint in child-frame at point]]
  - [[#lisp-editing][Lisp editing]]
  - [[#never-expire-passwords][Never expire passwords]]
  - [[#pinentry][Pinentry]]
  - [[#abbrevs][Abbrevs]]
  - [[#arduino-mode][Arduino mode]]
  - [[#lispify-eldoc-message][Lispify eldoc message]]
  - [[#setup-notification-style][Setup notification style]]
  - [[#show-command-frequency][Show command frequency]]
  - [[#automatic-capitalization][Automatic capitalization]]
  - [[#deadgrep][Deadgrep]]
  - [[#sunrise-commander-a-two-pane-version-of-dired][Sunrise Commander, a two-pane version of Dired.]]
  - [[#show-if-paths-exist-path-check-mode][Show if paths exist (path-check-mode)]]
  - [[#debug-font-lock-keywords][Debug font-lock-keywords]]
  - [[#spelling][Spelling]]
  - [[#annotations][Annotations]]
  - [[#insert-junk-text][Insert junk text]]
  - [[#lookup][Lookup]]
  - [[#system][System]]
  - [[#miscellaneous-applications][Miscellaneous applications]]
  - [[#games][Games]]
  - [[#quotes][Quotes]]
  - [[#eye-candy][Eye candy]]
- [[#doom-modules][Doom modules]]
  - [[#smartparens][Smartparens]]
  - [[#fill-column][Fill column]]
  - [[#popups][Popups]]
  - [[#workspaces][Workspaces]]
  - [[#eshell][Eshell]]
  - [[#evil][Evil]]
  - [[#company][Company]]
  - [[#latex][LaTeX]]
  - [[#helm][Helm]]
  - [[#ivy][Ivy]]
  - [[#dired][Dired]]
  - [[#calendar][Calendar]]
  - [[#org][Org]]
  - [[#email][Email]]
  - [[#terminal][Terminal]]
  - [[#pdf-viewer][PDF viewer]]
  - [[#proof-assistants][Proof assistants]]

* Preamble
** Enable lexical scoping
#+BEGIN_SRC emacs-lisp :tangle yes
;;; ~/.doom.d/config.el -*- lexical-binding: t; -*-
#+END_SRC
** Speed up garbage collection in exchange for increased memory usage
#+BEGIN_SRC emacs-lisp :tangle yes
(setq inhibit-compacting-font-caches t)
#+END_SRC
** Use cache for font-utils
#+BEGIN_SRC emacs-lisp :tangle yes
(after! font-utils
  (setq font-utils-use-memory-cache t))
#+END_SRC
** Set default fonts
#+BEGIN_SRC emacs-lisp :tangle yes
(setq doom-font (font-spec :family "Iosevka" :size 16)
      doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size 17)
      doom-unicode-font (font-spec :family "DejaVu Sans Mono" :size 19)
      doom-serif-font (font-spec :family "IBM Plex Serif" :size 19)
      )
#+END_SRC
** Set default web browser
#+BEGIN_SRC emacs-lisp :tangle yes
(setq browse-url-browser-function #'browse-url-generic
      browse-url-generic-program "qutebrowser")
#+END_SRC
** Set source directory
#+BEGIN_SRC emacs-lisp :tangle yes
(setq source-directory (expand-file-name "~/src/emacs-libjit/src")
      find-function-C-source-directory source-directory)
#+END_SRC
** COMMENT Set up on-save byte compilation
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'auto-async-byte-compile)
(setq auto-async-byte-compile-suppress-warnings t)
(add-hook 'emacs-lisp-mode-hook #'enable-auto-async-byte-compile-mode)
(setq auto-async-byte-compile-init-file
      (expand-file-name "oof-bytecomp-init.el" doom-private-dir))
#+END_SRC
** Disable suspend frame outside of terminal
#+BEGIN_SRC emacs-lisp :tangle yes
(when (display-graphic-p)
  (global-set-key [remap suspend-frame] #'ignore))
#+END_SRC
** Set up calendar (the package calendar)
#+BEGIN_SRC emacs-lisp :tangle yes
(after! solar
  (setq calendar-latitude 40.11060)
  (setq calendar-longitude -88.20730)
  (setq calendar-location-name "Urbana, IL"))

(after! calendar
  (setq calendar-week-start-day 1))
#+END_SRC
** Set up email address & full name
#+BEGIN_SRC emacs-lisp :tangle yes
(load (expand-file-name "email-address" doom-private-dir))
#+END_SRC
** Recent files configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(defun +org-is-agenda-file (filename)
  (cl-find (file-truename filename) (bound-and-true-p org-agenda-files)
           :key #'file-truename
           :test #'equal))

(after! recentf
  ;; don't clobber recentf with agenda files
  (push #'+org-is-agenda-file recentf-exclude)
  (push "~/.mail" recentf-exclude)
  (push "\\.git" recentf-exclude)
  (push "/tmp/" recentf-exclude)
  (push "/ssh:" recentf-exclude)
  (push "~/\\.emacs\\.d/.local" recentf-exclude)
  (push "~/mail" recentf-exclude)
  (push "/var" recentf-exclude)
  (push "/usr" recentf-exclude)
  (push "\\.?ido\\.last$" recentf-exclude)
  (push "^/nix/store/" recentf-exclude)
  (push ".+\\.mp3$" recentf-exclude))
#+END_SRC
** Set default printer
#+BEGIN_SRC emacs-lisp :tangle yes
(after! lpr (setq printer-name "Brother_HL-L2320D_series"))
(after! ps-print (setq ps-printer-name "Brother_HL-L2320D_series"))
#+END_SRC
** Use relative line numbers
#+BEGIN_SRC emacs-lisp :tangle yes
(after! display-line-numbers (setq display-line-numbers-type 'relative))
#+END_SRC
** Add startpage as search provider
#+BEGIN_SRC emacs-lisp :tangle yes
(when (boundp '+lookup-provider-url-alist)
  (let ((startpage-entry
         (cons "startpage"
               "https://www.startpage.com/do/search?query=%s&?prf=7de10a290cc3cee4fa552d4b43dc3f48")))
    (setq +lookup-provider-url-alist (assoc-delete-all "google" +lookup-provider-url-alist))
    (add-to-list '+lookup-provider-url-alist startpage-entry)))
#+END_SRC
** Turn off shift selection
#+BEGIN_SRC emacs-lisp :tangle yes
(setq shift-select-mode nil)
#+END_SRC
** COMMENT Set up mouse banishment
#+BEGIN_SRC emacs-lisp :tangle yes
(after! posframe
  (setq posframe-mouse-banish nil))
(mouse-avoidance-mode 'jump)
#+END_SRC
** Enable el-patch
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:57]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'el-patch)
(el-patch-use-package-mode +1)
#+END_SRC

#+RESULTS:
: t

** Disable modeline force update (does this improve performance?)
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:05]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add #'force-mode-line-update :override #'ignore)
#+END_SRC
** Enable transparent encryption/decryption of files
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 13:58]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! epa-file
  :defer-incrementally t
  :config
  (epa-file-enable))
#+END_SRC
** Emacs-Libjit
:PROPERTIES:
:CREATED_TIME: [2020-01-19 Sun 14:19]
:END:
*** Broken advices
**** +evil-delete-region-if-mark-a
#+BEGIN_SRC emacs-lisp :tangle yes
(when (and (fboundp #'jit-disassemble)
           (fboundp #'+evil-delete-region-if-mark-a))
  (advice-remove #'evil-delete-backward-char-and-join #'+evil-delete-region-if-mark-a)
  (defadvice evil-delete-backward-char-and-join (around +evil-delete-region-if-mark-a (&rest args) activate)
    (apply #'+evil-delete-region-if-mark-a args)))
#+END_SRC
**** +org-realign-table-maybe-a
:PROPERTIES:
:CREATED_TIME: [2020-01-19 Sun 14:57]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (and (fboundp #'jit-disassemble)
           (fboundp #'+org-realign-table-maybe-a))
  (advice-add #'+org-enable-auto-reformat-tables-h
              :after
              (lambda (&rest _)
                (advice-remove #'evil-replace #'+org-realign-table-maybe-a)
                (defadvice evil-replace (after +org-realign-table-maybe-a (&rest args) activate)
                  (apply #'+org-realign-table-maybe-a args)))))
#+END_SRC
**** mu4e-conversation--update-handler-extra
:PROPERTIES:
:CREATED_TIME: [2020-01-19 Sun 15:19]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp #'jit-disassemble)
  (after! mu4e-conversation
    (add-hook! 'mu4e-conversation-mode-hook
      (defadvice mu4e~headers-update-handler
          (after
           mu4e-conversation--update-handler-extra (&rest args)
           activate)
        (apply #'mu4e-conversation--update-handler-extra args))

      (advice-remove #'mu4e~headers-update-handler #'mu4e-conversation--update-handler-extra))))
#+END_SRC
**** amx-post-eval-force-update
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 06:06]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! amx
  (cl-loop for fun in '(load eval-last-sexp eval-buffer eval-region eval-expression autoload-do-load)
           do (progn (advice-remove fun #'amx-post-eval-force-update)
                     (eval `(defadvice ,fun (after amx-post-activate)
                              (amx-post-eval-force-update))))))
#+END_SRC
**** shell-command--shell-command-with-editor-mode
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 06:12]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp #'jit-disassemble)
  (after! with-editor
    (advice-remove #'shell-command #'shell-command--shell-command-with-editor-mode)))
#+END_SRC
**** +evil--dont-move-cursor-a
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 12:21]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp #'jit-disassemble)
  (after! evil
    (advice-remove #'evil-indent #'+evil--dont-move-cursor-a)
    (defadvice evil-indent (around +evil--dont-move-cursor-a (&rest args)
                                   activate)
      (save-excursion ad-do-it))))
#+END_SRC
**** +evil/repeat-evil-snipe-s and similar
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 15:25]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (fboundp #'jit-disassemble)
  (after! evil-snipe
    (advice-remove #'evil-snipe-s
                   #'+evil/repeat-evil-snipe-s)
    (advice-remove #'evil-snipe-S
                   #'+evil/repeat-evil-snipe-S)
    (advice-remove #'evil-snipe-f
                   #'+evil/repeat-evil-snipe-f)
    (advice-remove #'evil-snipe-F
                   #'+evil/repeat-evil-snipe-F)
    (advice-remove #'evil-snipe-t
                   #'+evil/repeat-evil-snipe-t)
    (advice-remove #'evil-snipe-T
                   #'+evil/repeat-evil-snipe-T)
    (advice-remove #'evil-snipe-x
                   #'+evil/repeat-evil-snipe-x)
    (advice-remove #'evil-snipe-X
                   #'+evil/repeat-evil-snipe-X)
    (defadvice evil-snipe-s
        (after +evil/repeat-evil-snipe-s
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-s args)))
    (defadvice evil-snipe-S
        (after +evil/repeat-evil-snipe-S
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-S args)))
    (defadvice evil-snipe-f
        (after +evil/repeat-evil-snipe-f
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-f args)))
    (defadvice evil-snipe-F
        (after +evil/repeat-evil-snipe-F
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-F args)))
    (defadvice evil-snipe-t
        (after +evil/repeat-evil-snipe-t
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-t args)))
    (defadvice evil-snipe-T
        (after +evil/repeat-evil-snipe-T
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-T args)))
    (defadvice evil-snipe-x
        (after +evil/repeat-evil-snipe-x
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-x args)))
    (defadvice evil-snipe-X
        (after +evil/repeat-evil-snipe-X
               (&rest args)
               activate)
      (when ad-return-value
        (apply #'+evil/repeat-evil-snipe-X args)))))
#+END_SRC

*** Super Save breaks when byte-compiled
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 12:57]
:END:
In packages.el, I have set up Super Save to install without being byte-compiled.
* Personal modules
** Translation layer for my keyboard layout
*** Define constants
#+BEGIN_SRC emacs-lisp :tangle yes
(defconst alphabet '(?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m ?n ?o ?p ?q ?r ?s ?t ?u ?v ?w ?x ?y ?z))

(defconst vowels '(?a ?e ?i ?o ?u))
(defconst numbers '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
(defconst consonants (cl-set-difference alphabet vowels))
(defconst common-starting-consonant-bigrams '("th" "tr" "sh" "tw" "sy" "fl"))
(defconst brackets '(?\[ ?\] ?\{ ?\} ?\( ?\)))
(defconst misc-symbols '(?. ?, ?- ?| ?_))
(defconst whitespace-chars '(?\t ?\s ?\n))
(defconst keyboard-layout-translation-alist
  '(("c" . "e")
    ("p" . "r")
    ("z" . "t")
    ("j" . "y")
    ("l" . "u")
    ("u" . "i")
    ("y" . "o")
    ("'" . "p")
    ("r" . "s")
    ("s" . "d")
    ("t" . "f")
    ("m" . "h")
    ("n" . "j")
    ("e" . "k")
    ("i" . "l")
    ("o" . ";")
    (";" . "\\")
    ("\\" . "'")
    ("x" . "z")
    ("v" . "x")
    ("f" . "c")
    ("d" . "v")
    ("k" . "n")
    ("h" . "m")

    ("a" . "a")
    ("q" . "q")
    ("w" . "w")
    ("g" . "g")

    ("C" . "E")
    ("P" . "R")
    ("Z" . "T")
    ("J" . "Y")
    ("L" . "U")
    ("U" . "I")
    ("Y" . "O")
    ("\"" . "P")
    ("R" . "S")
    ("S" . "D")
    ("T" . "F")
    ("M" . "H")
    ("N" . "J")
    ("E" . "K")
    ("I" . "L")
    ("O" . ":")
    (":" . "|")
    ("|" . "\"")
    ("X" . "Z")
    ("V" . "X")
    ("F" . "C")
    ("D" . "V")
    ("K" . "N")
    ("H" . "M")))
(defconst keyboard-layout-prefix-keys '("g" "z" "gz"))
(defconst symbol-bigrams '("t;" ":"
                           "t`" "~"
                           "t7" "&"
                           "t8" "*"
                           "t9" "("
                           "t0" ")"
                           ;; "t\\" "|"
                           ;; "t/" "?"
                           ;; "t." ">"
                           ;; "t," "<"
                           ;; "t'" "\""
                           ;; "t]" "}"
                           ;; "t[" "{"
                           "n`" "~"
                           ":;" "::"
                           ;; "n2" "@"
                           "n1" "!"
                           ;; "n3" "#"
                           "n4" "$"
                           "n5" "%"
                           ;;"n6" "^"
                           "n8" "*"
                           "n=" "+"
                           ",=" "<="
                           ".=" ">="
                           "=." "=>"
                           ;; "n-" "_"
                           "-." ("->" "‚Üí")
                           ",-" ("<-" "‚ÜΩ")
                           "`." ("~>" "‚§≥")
                           ",`" ("<~" "‚¨ø")
                           "~." ("~>" "‚§≥")
                           ",." "|"
                           "‚ÜΩ." "‚Üî"
                           ".-" "‚à∏"
                           "‚à∏." "√∑"
                           ))
(defconst symbol-trigrams '(
                            "bnn" "‚Ñï"
                            "bnb" "ùîπ"
                            "bnr" "‚Ñù"
                            "bnv" "ùïç"
                            "bna" "ùî∏"
                            "bnc" "‚ÑÇ"
                            "bnd" "ùîª"
                            "bne" "ùîº"
                            "bnf" "ùîΩ"
                            "bnw" "ùïé"
                            "bnq" "‚Ñö"
                            "bno" "ùïÜ"
                            "bnj" "ùïÅ"
                            "bnz" "‚Ñ§"
                            "bny" "ùïê"
                            "bnt" "ùïã"
                            "bnl" "ùïÉ"
                            "bng" "ùîæ"
                            "bnx" "ùïè"
                            "bni" "ùïÄ"
                            "bnm" "ùïÑ"
                            "bnk" "ùïÇ"
                            "bnh" "‚Ñç"
                            "bnp" "‚Ñô"
                            "bns" "ùïä"
                            "bnu" "ùïå"
                            ))
#+END_SRC

#+RESULTS:
: symbol-trigrams

*** For defining new keybindings independent of keyboard layout
#+BEGIN_SRC emacs-lisp :tangle yes
(defconst kbl-translation-alist
  (mapcar (lambda (l)
            (setq l (cons (cdr l) (car l))))
          keyboard-layout-translation-alist))

(defconst kbl-reverse-translation-alist
  (mapcar (lambda (l)
            (setq l (cons (cdr l) (car l))))
          kbl-translation-alist))

(defconst kbl-admissible-prefixes
  (mapcar (lambda (x) (string-to-char (car x)))
          keyboard-layout-translation-alist))

(defun kbl-print (s &optional control-p meta-p shift-p super-p)
  "The modifiers are in alphabetical order: Control -> Meta -> Shift -> Super"
  (declare (pure t) (side-effect-free t))
  (concat (and control-p "C-")
          (and meta-p "M-")
          (and shift-p "S-")
          (and super-p "s-")
          (alist-get s kbl-translation-alist s nil #'equal)))

(defun kbl-print-reverse (s &optional control-p meta-p shift-p super-p)
  "The modifiers are in alphabetical order: Control -> Meta -> Shift -> Super"
  (declare (pure t) (side-effect-free t))
  (concat (and control-p "C-")
          (and meta-p "M-")
          (and shift-p "S-")
          (and super-p "s-")
          (alist-get s kbl-reverse-translation-alist s nil #'equal)))

(defun kbl-kbd (s &optional control-p meta-p shift-p super-p)
  (kbd (kbl-print s control-p meta-p shift-p super-p)))
#+END_SRC

#+RESULTS:
: kbl-kbd

*** Translate my keyboard layout to qwerty during insert state
#+BEGIN_SRC emacs-lisp :tangle yes
(defun make-conditional-key-translation (key-from key-to translate-keys-p)
  "Make a Key Translation such that if the translate-keys-p function returns true,
   key-from translates to key-to, else key-from translates to itself.  translate-keys-p
   takes key-from as an argument. "
  (define-key key-translation-map key-from
    (lambda (prompt)
      (if (funcall translate-keys-p key-from) key-to key-from))))

(defvar evil-colemak-xvcf-enabled t)

(defun toggle-evil-colemak-xvcf ()
  (interactive)
  (if evil-colemak-xvcf-enabled
      (setq evil-colemak-xvcf-enabled nil)
    (setq evil-colemak-xvcf-enabled t)))

(global-set-key (kbd "M-s-SPC") #'toggle-evil-colemak-xvcf)

(defun my-translate-keys-p (key-from)
  (declare (side-effect-free t))
  "Returns whether conditional key translations should be active.  See make-conditional-key-translation function. "
  (and evil-colemak-xvcf-enabled
       ;; Only allow a non identity translation if we're beginning a Key Sequence.
       ;; (equal key-from (this-command-keys))
       (not isearch-mode)
       (or (memq (aref (this-command-keys) 0) kbl-admissible-prefixes)
           (eq (aref (this-command-keys) 0) 'easymotion)
           (equal key-from (this-command-keys)))
       (and (or (evil-motion-state-p)
                (evil-normal-state-p)
                (evil-visual-state-p)
                (evil-operator-state-p))
            (not (or (bound-and-true-p avy--overlays-back)
                     (bound-and-true-p avy--overlays-lead)
                     (string-prefix-p "evil-snipe-" (symbol-name this-command)))))))

(cl-loop for p in keyboard-layout-translation-alist
         do (make-conditional-key-translation (kbd (car p)) (kbd (cdr p)) #'my-translate-keys-p))

(make-conditional-key-translation (kbl-kbd "v" 'control) (kbd "C-v") #'my-translate-keys-p)
(make-conditional-key-translation (kbd "C-v") (kbl-kbd "v" 'control) #'my-translate-keys-p)
#+END_SRC
*** COMMENT Swap [] with () in certain modes
#+BEGIN_SRC emacs-lisp :tangle yes
(defun insert-correct-brackets-for-mode ()
  (when (and (or (memq major-mode '(emacs-lisp-mode
                                    minibuffer-inactive-mode
                                    org-mode)))
             (or (evil-insert-state-p)
                 (not evil-state))
             (eq (length (this-command-keys-vector))
                 1))
    (cond ((eq (aref (this-command-keys-vector)
                     0)
               ?\[)
           (setq last-command-event ?\())
          ((eq (aref (this-command-keys-vector)
                     0)
               ?\])
           (setq last-command-event ?\)))
          ((eq (aref (this-command-keys-vector)
                     0)
               ?\()
           (setq last-command-event ?\[))
          ((eq (aref (this-command-keys-vector)
                     0)
               ?\))
           (setq last-command-event ?\]))
          )))

(add-hook 'pre-command-hook #'insert-correct-brackets-for-mode)
#+END_SRC

*** A wannabe input method for symbols and correcting typos
#+BEGIN_SRC emacs-lisp :tangle yes
(defun correct-symbol-ngram ()
  (let* ((l 0)
         (s (or (and (> (point) 2)
                     ;; Character before is not a letter or bigram has a number
                     (or (not (memq (char-before (- (point) 2))
                                    (cons ?\' alphabet)))
                         (memq (char-before) numbers)
                         (memq (char-before) brackets)
                         (memq (char-before) misc-symbols))
                     (let ((output (lax-plist-get symbol-bigrams (buffer-substring-no-properties
                                                                  (max (point-min) (- (point) 2))
                                                                  (point)))))
                       (when output
                         (setq l 2)
                         output)))
                (and (> (point) 2)
                     (or (not (memq (char-before (- (point) 3))
                                    (cons ?\' alphabet)))
                         (memq (char-before) numbers)
                         (memq (char-before) brackets)
                         (memq (char-before) misc-symbols)
                         (memq (char-before (- (point) 2)) whitespace-chars))
                     (let ((output  (lax-plist-get symbol-trigrams (buffer-substring-no-properties
                                                                    (max (point-min) (- (point) 3))
                                                                    (point)))))
                       (when output
                         (setq l 3)
                         output))
                     ))))
    (when s
      (when (or (and (s-matches? "~" (or (and (stringp s) s)
                                         (car s)))
                     (eq (char-after) ?`))
                (and (s-matches? "{" (or (and (stringp s) s)
                                         (car s)))
                     (eq (char-after) ?\])))
        (delete-char 1))
      (when (listp s)
        (if (memq major-mode '(text-mode
                               agda2-mode
                               org-mode))
            (setq s (second s))
          (setq s (first s))))
      (delete-char (- l))
      (setq unread-input-method-events (string-to-list s)))))

(add-hook 'post-self-insert-hook #'correct-symbol-ngram)
#+END_SRC
*** Swap the semicolon and colon in certain modes & scenarios
#+BEGIN_SRC emacs-lisp :tangle yes
(defun swap-semicolon-colon ()
  (when (or (and (memq major-mode
                       '(agda2-mode
                         haskell-mode
                         ))
                 (eq (length (this-command-keys-vector))
                     1)))
    (cond ((eq (aref (this-command-keys-vector)
                     0)
               ?\;)
           (setq last-command-event
                 ?:))
          ((eq (aref (this-command-keys-vector)
                     0)
               ?:)
           (setq last-command-event
                 ?\;)))))

(add-hook 'pre-command-hook #'swap-semicolon-colon)
#+END_SRC

#+RESULTS:
| swap-semicolon-colon | sp--save-pre-command-state | gcmh-set-high-threshold | evil-escape-pre-command-hook | which-key--hide-popup | exwm-input--on-pre-command | magit-pre-command-hook | keyfreq-pre-command-hook | evil-repeat-pre-hook | eldoc-pre-command-refresh-echo-area |

*** Why would I ever write "I a "?
#+BEGIN_SRC emacs-lisp :tangle yes
(defun _I_a_->_I_am_ ()
  (when (and (>= (point) (length " I a "))
             (member (buffer-substring-no-properties (max (point-min) (- (point) (length " I a ")))
                                                     (point))
                     '(" I a " "\nI a " "\tI a ")))
    (save-excursion (forward-char -1)
                    (insert-char ?m))))

(add-hook 'post-self-insert-hook #'_I_a_->_I_am_)
#+END_SRC
*** Auto-correct more typos due Qukeys-related typos
#+BEGIN_SRC emacs-lisp :tangle yes :tangle yes
(defun correct-shifted-char ()
  (let (start end)
    (let ((s (save-excursion
               (buffer-substring-no-properties
                (progn (search-backward-regexp "[^a-zA-Z]" nil t)
                       (forward-char 1)
                       (setq start (point)))
                (progn (if (search-forward-regexp "[^a-zA-Z]" nil t)
                           (forward-char -1)
                         (end-of-line))
                       (setq end (point)))))))
      ;; (message "%s %s %s %s %s" s
      ;;          (and (> (length s) 3) (memq (aref s 1) consonants))
      ;;          start end
      ;;          (and (> (length s) 3)
      ;;               (concat (upcase (substring-no-properties s 1 2))
      ;;                       (substring-no-properties s 2 nil))))
      (when (and (> (length s) 3)
                 (eq (aref s 0) ?n)
                 (memq (aref s 1) consonants)
                 (not (string-prefix-p "ngin" s))
                 (not (string-prefix-p "nlab" s))
                 (or (memq (aref s 2) vowels)
                     (member (substring-no-properties s 1 3)
                             common-starting-consonant-bigrams)))
        (ignore-errors (delete-region start end)
                       (insert (concat (upcase (substring-no-properties s 1 2))
                                       (substring-no-properties s 2 nil))))))))

(add-hook 'post-self-insert-hook #'correct-shifted-char)
#+END_SRC

#+RESULTS:
| correct-shifted-char | sp--post-self-insert-hook-handler | _I_a_->_I_am_ | electric-indent-post-self-insert-function |
** Automatically center windows
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 18:14]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! perfect-margin
  :custom
  (perfect-margin-visible-width 128)
  :config
  ;; enable perfect-mode
  (perfect-margin-mode t)
  
  ;; add additinal bding on margin area
  (dolist (margin '("<left-margin> " "<right-margin> "))
    (global-set-key (kbd (concat margin "<mouse-1>")) 'ignore)
    (global-set-key (kbd (concat margin "<mouse-3>")) 'ignore)
    (dolist (multiple '("" "double-" "triple-"))
      (global-set-key (kbd (concat margin "<" multiple "wheel-up>")) 'mwheel-scroll)
      (global-set-key (kbd (concat margin "<" multiple "wheel-down>")) 'mwheel-scroll))))
#+END_SRC
** Hippie expand
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 16:39]
:END:
*** Replace dabbrev expand
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 16:55]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! hippie-exp
  :config
  (defun my/he-try-expand-flx-regexp (str)
    "Generate regexp for flexible matching of str."
    (concat (rx word-boundary)
            (mapconcat (lambda (x)
                         (concat (rx (zero-or-more word) (zero-or-more "-"))
                                 (list x)))
                       str
                       "")
            (rx (zero-or-more word) word-boundary)))

  (defun my/he-try-expand-flx-collect (str)
    "Find and collect all words that flex-match str, and sort by flx score"
    (let ((coll)
          (regexp (my/he-try-expand-flx-regexp str)))
      (save-excursion
        (goto-char (point-min))
        (while (search-forward-regexp regexp nil t)
          (push (thing-at-point 'symbol) coll)))
      (sort coll #'(lambda (a b)
                     (> (car (flx-score a str))
                        (car (flx-score b str)))))))

  (defun my/he-try-expand-flx (old)
    "Try to complete word using flx matching."
    (unless old
      (he-init-string (he-lisp-symbol-beg) (point))
      (unless (he-string-member he-search-string he-tried-table)
        (push he-search-string he-tried-table))
      (setq he-expand-list
            (unless (equal he-search-string "")
              (my/he-try-expand-flx-collect he-search-string))))
    (while (and he-expand-list
                (he-string-member (car he-expand-list) he-tried-table))
      (pop he-expand-list))
    (prog1
        (null he-expand-list)
      (if (null he-expand-list)
          (when old (he-reset-string))
        (he-substitute-string (pop he-expand-list)))))

  (setq hippie-expand-try-functions-list
        '(yas-hippie-try-expand
          try-expand-dabbrev
          try-expand-dabbrev-from-kill
          try-expand-dabbrev-all-buffers
          try-complete-file-name-partially
          try-complete-file-name
          ;; my/he-try-expand-flx
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol
          )))

;; (global-set-key (kbd "M-/") #'hippie-expand)
(global-set-key (kbd "C-c C-/") #'hippie-expand)
#+END_SRC

#+RESULTS:
: hippie-expand

** Visual scrolling
https://with-emacs.com/posts/ui-hacks/keep-scrollin-scrollin-scrollin/
I have added some modifications for better compatibility with evil mode
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 16:33]
:END:
#+begin_src emacs-lisp :tangle yes
(autoload 'View-scroll-half-page-forward "view")
(autoload 'View-scroll-half-page-backward "view")

(global-set-key (kbd "C-v") 'View-scroll-half-page-forward)
(global-set-key (kbd "M-v") 'View-scroll-half-page-backward)

(global-set-key (kbd "C-M-v")
                'my-View-scroll-half-page-forward-other-window)
(global-set-key (kbd "C-M-S-v")
                'my-View-scroll-half-page-backward-other-window)

(when (featurep 'evil)
  (global-set-key [remap evil-scroll-down] #'View-scroll-half-page-forward)
  (global-set-key [remap evil-scroll-up] #'View-scroll-half-page-backward))

(defun my-View-scroll-half-page-forward-other-window ()
  (interactive)
  (with-selected-window (next-window)
    (call-interactively 'View-scroll-half-page-forward)))

(defun my-View-scroll-half-page-backward-other-window ()
  (interactive)
  (with-selected-window (next-window)
    (call-interactively 'View-scroll-half-page-backward)))

(setq scroll-preserve-screen-position 'always)

(advice-add #'View-scroll-half-page-forward :around
            #'my-indicate-scroll-forward)

(advice-add #'View-scroll-half-page-backward :around
            #'my-indicate-scroll-backward)

(defun my-indicate-scroll-get-line (pos)
  (save-excursion
    (goto-char pos)
    (string-to-number (format-mode-line "%l"))))

(defun my-indicate-scroll (linep f args)
  (let ((linen (my-indicate-scroll-get-line linep))
        (pulse-delay 0.1))
    (set-transient-map
     `(keymap ,@(if (and (featurep 'evil)
                         (not (evil-emacs-state-p)))
                    (list (cons (string-to-char (if evil-colemak-xvcf-enabled (kbl-print-reverse "v") "d")) #'View-scroll-half-page-forward)
                          (cons (string-to-char (if evil-colemak-xvcf-enabled (kbl-print-reverse "u") "u")) #'View-scroll-half-page-backward))
                  (cons ?v real-this-command))))
    (save-excursion
      (goto-line linen)
      (pulse-momentary-highlight-one-line (point) 'highlight))
    (sit-for 0.1)
    (apply f args)))

(defun my-indicate-scroll-forward (f &rest args)
  (my-indicate-scroll (1- (window-end)) f args))

(defun my-indicate-scroll-backward (f &rest args)
  (my-indicate-scroll (window-start) f args))
#+end_src

#+RESULTS:
: my-indicate-scroll-backward

:CREATED_TIME: [2020-01-16 Thu 16:49]
:END:
** Copy a defun for Reddit
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 09:04]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(defun indented-copy-for-reddit ()
  "Copy and indent active region or current defun."
  (interactive)
  (when-let* ((bounds (if (region-active-p)
                          (cons (region-beginning) (region-end))
                        (bounds-of-thing-at-point 'defun)))
              (text (buffer-substring-no-properties (car bounds) (cdr bounds))))
    (setq deactivate-mark t)
    (kill-new (replace-regexp-in-string "^" "    " text))
    (message "Copied!")))
#+END_SRC
** Basic keybindings
*** Bind C-DEL to kill line backwards
#+BEGIN_SRC emacs-lisp :tangle yes
(defun crux-kill-line-backwards ()
  "Kill line backwards and adjust the indentation."
  (interactive)
  (kill-line 0)
  (indent-according-to-mode))

(if (display-graphic-p)
    (global-set-key (kbd "<C-backspace>") #'crux-kill-line-backwards)
  (global-set-key (kbd "C-DEL") #'crux-kill-line-backwards))
#+END_SRC
*** Previous buffer & next buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbl-kbd "u" nil nil nil 'super) #'previous-buffer)
(global-set-key (kbl-kbd "i" nil nil nil 'super) #'next-buffer)
#+END_SRC
*** Window keybindings for typos
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-x C-1") #'delete-other-windows)
(global-set-key (kbd "C-x C-2") #'split-window-below)
(global-set-key (kbd "C-x C-3") #'split-window-right)
(global-set-key (kbd "C-x C-0") #'delete-window)
#+END_SRC
*** Keyboardio chord keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbl-kbd "b" 'control 'meta nil 'super) #'bookmark-jump)
#+END_SRC
*** COMMENT Evil
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 16:08]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor evil)
  (map! :m "C-v" #'scroll-down-command
        :m "C-d" #'evil-visual-block))
#+END_SRC
** Filter echo area messages
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar message-filter-regexp-list '("^Starting new Ispell process \\[.+\\] \\.\\.\\.$"
                                     "^Ispell process killed$")
  "filter formatted message string to remove noisy messages")

(defadvice message (around message-filter-by-regexp activate)
  (if (not (ad-get-arg 0))
      ad-do-it
    (let ((formatted-string (apply 'format (ad-get-args 0))))
      (if (and (stringp formatted-string)
               (some (lambda (re) (string-match re formatted-string)) message-filter-regexp-list))
          (save-excursion
            (set-buffer "*Messages*")
            (goto-char (point-max))
            (insert formatted-string "\n"))
        (progn
          (ad-set-args 0 `("%s" ,formatted-string))
          ad-do-it)))))

;; Searched 1/1 files
(add-to-list 'message-filter-regexp-list "^Searched [0-9]/[0-9] files$")

;; Note: file is write-protected
(add-to-list 'message-filter-regexp-list "^Note: file is write protected$")

;; auto-async-byte-compile -file name- completed with warnings.
(add-to-list 'message-filter-regexp-list
             "^auto-async-byte-compile .+completed with warnings.$")

;; End of buffer.
(defun my-command-error-function (data context caller)
  "Ignore the buffer-read-only, beginning-of-buffer,
end-of-buffer signals; pass the rest to the default handler."
  (when (not (memq (car data) '(buffer-read-only
                                beginning-of-buffer
                                end-of-buffer)))
    (command-error-default-function data context caller)))

(setq command-error-function #'my-command-error-function)

;; turn off auto revert messages
(setq auto-revert-verbose nil)
#+END_SRC
** Emacs Application Framework
:PROPERTIES:
:CREATED_TIME: [2020-01-24 Fri 21:34]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! eaf
  :defer-incrementally t
  :custom
  (eaf-find-alternate-file-in-dired t)
  :config
  (eaf-bind-key scroll_up "RET" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down_page "DEL" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  (eaf-bind-key take_photo "p" eaf-camera-keybinding)

  (defvar buffer-url nil)
  (defun eaf-start-process-in-nix-shell ()
    (interactive)
    (if (process-live-p eaf-process)
        (message "EAF process has started.")
      (setq eaf-process
            (apply 'start-process
                   eaf-name
                   eaf-name
                   "nix-shell"
                   "-p"
                   "qutebrowser"
                   "python3Packages.pip"
                   "python3Packages.xlib"
                   "python3Packages.pyqt5_with_qtwebkit"
                   "python3Packages.pyqrcode"
                   "python3Packages.dbus-python"
                   "python3Packages.pydbus"
                   "python3Packages.pyqtwebengine"
                   "python3Packages.pymediainfo"
                   "python3Packages.poppler-qt5"
                   "python3Packages.pymupdf"
                   "python3Packages.feedparser"
                   "python3Packages.grip"
                   "grip"
                   "qt5Full"
                   "--run"
                   (eaf-format-nix-shell-args eaf-python-command
                                              (list eaf-python-file)
                                              (eaf-get-render-size)
                                              (list eaf-proxy-host eaf-proxy-port eaf-proxy-type (concat user-emacs-directory "eaf"))
                                              (list (string-join (cl-loop for (key . value) in eaf-var-list
                                                                          collect (format "%s·õù%s" key value)) "·õ°")))))
      (set-process-query-on-exit-flag eaf-process nil)
      (set-process-sentinel
       eaf-process
       (lambda (process event)
         (message (format "%s %s" process event))
         ))
      (message "EAF process starting...")))

  (advice-add #'eaf-start-process :override #'eaf-start-process-in-nix-shell)

  (evil-set-initial-state 'eaf-mode 'emacs)

  (defun eaf-format-nix-shell-args (python-command &rest string-list-list)
    (list (concat python-command
                  " "
                  (mapconcat (lambda (x)
                               (if (string-blank-p x)
                                   "\"\""
                                 x))
                             (-flatten string-list-list)
                             " ")))))
#+END_SRC

** EXWM
**** Mouse follows focus
#+BEGIN_SRC emacs-lisp :tangle yes
(when (display-graphic-p)
  (use-package! exwm-mff
    :hook (exwm-init . exwm-mff-mode)
    :config
    (defvar exwm-mff-focused-window-before-warp nil)
    (defvar exwm-mff-disabled-p nil)

    (defun exwm-mff-hook-advice (oldfun &rest args)
      (if (eq exwm-mff-focused-window-before-warp (get-buffer-window))
          (progn (setq exwm-mff-focused-window-before-warp (get-buffer-window))
                 (apply oldfun args))
        (setq exwm-mff-focused-window-before-warp (get-buffer-window))))

    (defun exwm-mff-warp-to-advice (oldfun window)
      (if (eq (buffer-local-value 'major-mode (window-buffer window)) 'exwm-mode)
          (funcall oldfun window)
        (set-mouse-position exwm-workspace--current 0 0)))

    (advice-add #'exwm-mff-hook :around #'exwm-mff-hook-advice)
    (advice-add #'exwm-mff-warp-to :around #'exwm-mff-warp-to-advice)

    (add-hook 'doom-switch-window-hook #'exwm-mff-hook)
    (add-hook 'doom-switch-frame-hook #'exwm-mff-hook)))
#+END_SRC
**** Unsorted configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(when (display-graphic-p)
  (require 'exwm-workspace)
  (require 'exwm-xim)
  (exwm-xim-enable)
  (require 'exwm)
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
  (exwm-enable)

  (add-hook 'exwm-mode-hook #'doom-mark-buffer-as-real-h)

  ;; let emacs handle these keys
  (dolist (k '(XF86AudioLowerVolume
               XF86AudioRaiseVolume
               XF86AudioPlay
               XF86AudioStop
               XF86AudioMute
               XF86AudioPrev
               XF86AudioNext
               ?\C-\S-f
               ?\C-\S-p
               ?\C-\S-n
               ?\C-\S-b
               ?\C-\S-l
               ?\C-\S-u
               ?\s-l
               ?\s-u
               ?\M-\S-1))
    (push k exwm-input-prefix-keys))

  (call-process-shell-command
   (string-join
    '("nvidia-settings -a '[gpu:0]/gpupowermizermode=1'
-a '[gpu:0]/gpufancontrolstate=1'
-a '[fan:0]/gputargetfanspeed=100'
-a '[fan:1]/gputargetfanspeed=100'
-a '[gpu:0]/gpumemorytransferrateoffset[4]=700'
-a '[gpu:0]/gpugraphicsclockoffset[4]=70' & ")
    " ")
   nil 0)

  ;; Start caldav adapter for etesync
  ;; (call-process-shell-command
  ;;  (string-join '("docker" "run" "--name" "etesync-dav" "-d" "-v"
  ;;                 "etesync-dav:/data" "-p" "37358:37358"
  ;;                 "-p" "37359:37359" "--restart=always" "etesync/etesync-dav")
  ;;               " ")
  ;;  nil "*etesync-dav*")

  (defun discord-start ()
    (interactive)
    (defvar discord-process nil)
    (setq discord-process
          (async-start-process "Discord" "Discord" nil))
    (require 'elcord)
    (elcord-mode +1))

  (defun steam-start ()
    (interactive)
    (defvar steam-process nil)
    (setq steam-process
          (async-start-process "steam" "steam" nil)))

  (defun discord-stop ()
    (interactive)
    (if (and (boundp 'discord-process)
             (processp discord-process))
        (progn (kill-process discord-process)
               (elcord-mode -1))
      (message "Discord is not running")))

  (defun steam-stop ()
    (interactive)
    (if (and (boundp 'steam-process)
             (processp steam-process))
        (kill-process steam-process)
      (message "Steam is not running")))

  (exwm-input-set-key
   (kbd "s-q")
   (lambda ()
     (interactive)
     (call-process-shell-command
      (concat "taskset 0x6 " browse-url-generic-program)
      nil 0)))

  (exwm-input-set-key
   (kbd "s-Q")
   (lambda ()
     (interactive)
     (call-process-shell-command "taskset 0x6 firefox" nil 0)))

  (exwm-input-set-key (kbd "M-;") #'eval-expression)

  (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
  (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name)))))
(add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))
#+END_SRC
**** Fix dialog boxes by tiling them
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 11:05]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! exwm
  (setq exwm-manage-force-tiling t))
#+END_SRC

#+RESULTS:
: t
**** Bind some commonly used commands
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 13:22]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! exwm
  (exwm-input-set-key
   [XF86MonBrightnessUp]
   (lambda ()
     (interactive)
     (call-process-shell-command "/run/current-system/sw/bin/light -A 10" nil 0)))

  (exwm-input-set-key
   [XF86MonBrightnessDown]
   (lambda ()
     (interactive)
     (call-process-shell-command "/run/current-system/sw/bin/light -U 10" nil 0)))

  (exwm-input-set-key
   (kbd "s-SPC")
   (lambda ()
     (interactive)
     (call-process-shell-command "urxvt" nil 0)
     (run-at-time 0.1 nil (lambda ()
                            (call-process-shell-command "xdotool click 1" nil 0)))))


  (exwm-input-set-key
   (kbd "s-L")
   (lambda ()
     (interactive)
     (call-process-shell-command "sudo slock" nil 0)))


  (exwm-input-set-key
   (kbd "s-l")
   (lambda ()
     (interactive)
     (call-process-shell-command "xtrlock-pam -b none" nil 0)))
  )
#+END_SRC
**** COMMENT Set up EXWM Randr (meant to be enabled using noweb)
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 11:54]
:END:
#+NAME: exwm-randr-setup
#+BEGIN_SRC emacs-lisp :tangle no :exports none
(require 'exwm-randr)
(setq exwm-randr-workspace-monitor-plist
      '(2 "HDMI-0" 1 "DP-5"  0 "DP-3")
      exwm-workspace-number 3)
(exwm-randr-enable)
#+END_SRC
**** COMMENT Set up exwmsw
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 12:01]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path (expand-file-name "exwmsw" doom-private-dir))
(require 'exwmsw)
(require 'exwmsw-org-noter)
(setq exwmsw-active-workspace-plist '("DP-5" 0 "DP-3" 0 "HDMI-0" 0)
      exwmsw-left-screen "DP-3"
      exwmsw-center-screen "HDMI-0"
      exwmsw-right-screen "DP-5")
(exwm-input-set-key (kbd "s-a") #'exwmsw-cycle-screens)
(exwm-input-set-key (kbd "s-r") #'exwmsw-switch-to-left-screen)
(exwm-input-set-key (kbd "s-s") #'exwmsw-switch-to-center-screen)
(exwm-input-set-key (kbd "s-t") #'exwmsw-switch-to-right-screen)
;; (exwm-input-set-key (kbd "s-r") #'exwmsw-swap-displayed-workspace-with-left-screen)
;; (exwm-input-set-key (kbd "s-s") #'exwmsw-swap-displayed-workspace-with-center-screen)
;; (exwm-input-set-key (kbd "s-t") #'exwmsw-swap-displayed-workspace-with-right-screen)
;; (exwm-input-set-key (kbd "s-w") #'exwmsw-cycle-workspace-on-left-screen)
;; (exwm-input-set-key (kbd "s-c") #'exwmsw-cycle-workspace-on-center-screen)
;; (exwm-input-set-key (kbd "s-p") #'exwmsw-cycle-workspace-on-right-screen)
;; (exwm-input-set-key (kbd "s-1") #'exwmsw-create-workspace-on-current-screen)
;; (exwm-input-set-key (kbd "s-d") #'exwmsw-delete-workspace-on-current-screen)
#+END_SRC
** Modeline in echo area
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'show-eol)
(require 'feebleline)
(require 's)

(defun jcs-current-major-mode ()
  "Get current major mode."
  major-mode)

(defun jcs--feebleline--symbol-read-only ()
  "Feebleline read-only symbol."
  (if buffer-read-only
      "R" ""))

(defun jcs--feebleline--project-name ()
  "Feebleline project name."
  (let ((project-root (cdr (project-current))))
    (if (and project-root
             (buffer-file-name))
        (concat " - " (file-name-nondirectory (directory-file-name project-root)))
      "")))

(defun jcs--feebleline--coding-system ()
  "Feebleline coding system."
  buffer-file-coding-system)

(defun jcs--feebleline--time ()
  "Feebleline time."
  (format-time-string "[%Y-%m-%d %H:%M:%S]"))

(defun oof-feebleline-systray-padding ()
  (make-string (max (- (* 3 (length (or (bound-and-true-p exwm-systemtray--list)
                                        ())))
                       2)
                    0)
               ?\s))

(defun oof-objed-modeline-string ()
  (when (featurep 'objed)
    (propertize
     (format " %s(%s) "
             (symbol-name objed--object)
             (char-to-string
              (aref
               (symbol-name objed--obj-state)
               0)))
     'face 'objed-mode-line)))

(defun oof-pdf-position ()
  (and (eq major-mode 'pdf-view-mode)
       (ignore-errors (pdf-view-current-page))
       (concat " P" (number-to-string (ignore-errors (pdf-view-current-page)))
               ;; Avoid errors during redisplay.
               "/"
               (or (ignore-errors
                     (number-to-string (pdf-cache-number-of-pages)))
                   "???"))))

(defun feebleline-buffer-position ()
  (or (oof-pdf-position)
      (format "%5s:%-2s" (feebleline-line-number)
              (feebleline-column-number))))

(defun oof-feebleline-rsync-status ()
  (bound-and-true-p dired-rsync-modeline-status))

(defun oof-emms-feebleline ()
  (bound-and-true-p emms-mode-line-string))

(defun oof-emms-playing-time ()
  (when (and (bound-and-true-p emms-playing-time-string)
             (not (string-empty-p emms-playing-time-string)))
    (s-trim emms-playing-time-string)))

(defun oof-mu4e-alert-unread-emails ()
  (when (and (bound-and-true-p mu4e-alert-mode-line)
             (not (string-empty-p mu4e-alert-mode-line)))
    (s-trim mu4e-alert-mode-line)))

(setq feebleline-msg-functions
      '((feebleline-buffer-position)
        (oof-objed-modeline-string :face objed-mode-line)
        (feebleline-file-directory :face feebleline-dir-face :post "")
        (feebleline-file-or-buffer-name :face font-lock-keyword-face :post "")
        (feebleline-file-modified-star :face font-lock-warning-face :post "")
        (feebleline-git-branch :face feebleline-git-face :pre " - ")
        (oof-mu4e-alert-unread-emails :align right)
        (oof-emms-feebleline :align right)
        (oof-emms-playing-time :pre "[" :post "] " :align right)
        (jcs--feebleline--time :align right)
        ;; my things
        (jcs--feebleline--coding-system :pre "[" :post "] " :align right)
        (oof-feebleline-systray-padding
         :align right)
        (oof-feebleline-rsync-status)))

(feebleline-mode +1)
#+END_SRC

** Replace text visually
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! anzu
  :defer-incrementally t
  :commands (anzu-query-replace
             anzu-query-replace-regexp)
  :bind (([remap query-replace] . anzu-query-replace)
         ([remap query-replace-regexp] . anzu-query-replace-regexp)
         (:map isearch-mode-map
           ([remap isearch-query-replace] . anzu-isearch-query-replace)
           ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))))
#+END_SRC
** Indent aggressively
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 23:43]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! aggressive-indent
  :after-call after-find-file
  :config
  (global-aggressive-indent-mode +1)
  (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
  (add-to-list 'aggressive-indent-excluded-modes 'eshell-mode)
  (add-to-list 'aggressive-indent-excluded-modes 'org-mode)
  (add-to-list
   'aggressive-indent-dont-indent-if
   '(and (derived-mode-p 'c++-mode 'nix-mode)
         (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                             (thing-at-point 'line))))))
#+END_SRC
** Show matching parens even when offscreen
https://with-emacs.com/posts/ui-hacks/show-matching-lines-when-parentheses-go-off-screen/
#+BEGIN_SRC emacs-lisp :tangle yes
;; we will call `blink-matching-open` ourselves...
(remove-hook 'post-self-insert-hook
             #'blink-paren-post-self-insert-function)
;; this still needs to be set for `blink-matching-open` to work
(setq blink-matching-paren 'show)

(let ((show-paren-off-screen--ov nil)) ; keep track of the overlay
  (defun show-paren--off-screen+ (&rest _args)
    "Display matching line for off-screen paren."
    (when (overlayp show-paren-off-screen--ov)
      (delete-overlay show-paren-off-screen--ov))
    ;; check if it's appropriate to show match info,
    ;; see `blink-paren-post-self-insert-function'
    (when (and (overlay-buffer show-paren--overlay)
               (not (or cursor-in-echo-area
                        executing-kbd-macro
                        noninteractive
                        (minibufferp)
                        this-command))
               (and (not (bobp))
                    (memq (char-syntax (char-before)) '(?\) ?\$)))
               (= 1 (logand 1 (- (point)
                                 (save-excursion
                                   (forward-char -1)
                                   (skip-syntax-backward "/\\")
                                   (point))))))
      ;; rebind `minibuffer-message' called by
      ;; `blink-matching-open' to handle the overlay display
      (cl-letf (((symbol-function #'minibuffer-message)
                 (lambda (msg &rest args)
                   (let ((msg (apply #'format-message msg args)))
                     (setq show-paren-off-screen--ov (display-line-overlay+
                                                      (window-start) msg ))))))
        (blink-matching-open))))
  (defadvice show-paren-function (after show-paren--off-screen+ (&rest _) activate)
    (defvar show-paren-off-screen--ov nil)
    (show-paren--off-screen+)))

(defun display-line-overlay+ (pos str &optional face)
  "Display line at POS as STR with FACE.

FACE defaults to inheriting from default and highlight."
  (let ((ol (save-excursion
              (goto-char pos)
              (make-overlay (line-beginning-position)
                            (line-end-position)))))
    (overlay-put ol 'display str)
    (overlay-put ol 'face
                 (or face '(:inherit default :inherit highlight)))
    ol))

(setq show-paren-style 'paren
      show-paren-delay 0.03
      show-paren-highlight-openparen t
      show-paren-when-point-inside-paren nil
      show-paren-when-point-in-periphery t)
(show-paren-mode 1)
#+END_SRC
** Save buffers upon switching focus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! super-save
  :after-call after-find-file
  :config
  (add-to-list 'super-save-triggers #'ace-window)
  (setq super-save-triggers nil
        super-save-auto-save-when-idle t
        super-save-exclude '("config.org"))
  (super-save-mode +1))
#+END_SRC
** Fontify page-break characters
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! page-break-lines
  :defer nil
  :config
  (global-page-break-lines-mode 1))
#+END_SRC
** Isearch configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(setq search-whitespace-regexp ".*?")
(setq isearch-lax-whitespace t)

(define-key isearch-mode-map [remap isearch-delete-char] 'isearch-delete+)

(defun isearch-delete+ ()
  "Delete the failed portion or last char if succesful search.

See also:

  https://emacs.stackexchange.com/a/10360/9198"
  (interactive)
  (if (= 0 (length isearch-string))
      (ding)
    (setq isearch-string
          (substring
           isearch-string 0 (or (isearch-fail-pos) (1- (length isearch-string))))
          isearch-message
          (mapconcat 'isearch-text-char-description isearch-string ""))
    (funcall (or isearch-message-function #'isearch-message) nil t)
    (if isearch-other-end (goto-char isearch-other-end))
    (isearch-search)
    (isearch-push-state)
    (isearch-update)))


(define-key isearch-mode-map (kbd "C-w")
  'isearch-kill-region+)

(defun isearch-kill-region+ ()
  "Kill text until match or pull text into search string.

If search string is empty forward to `isearch-yank-word-or-char'.
Otherwise exit search and kill text from where search was started
until the current match."
  (interactive)
  (if (or (string= "" isearch-string)
          (eq last-command this-command))
      (isearch-yank-word-or-char)
    (isearch-exit)
    (goto-char isearch-other-end)
    (kill-region
     isearch-opoint (point))))
#+END_SRC
** Avy configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(after! avy
  (setq avy-all-windows t
        avy-timeout-seconds 0.3
        avy-single-candidate-jump t
        avy-keys '(?q ?a ?r ?s ?t ?i
                      ?e ?n ?g ?m
                      ?w ?c ?p
                      ?' ?y ?u ?l
                      ?z ?j ?x ?v
                      ?f ?d ?h ?k
                      ?b ?, ?.
                      ?/ ?0 ?1 ?2 ?3
                      ?4 ?5 ?6 ?7 ?8
                      ?9 ?\; ?= ?-
                      ?\\
                      ?\[ ?\] ?\`
                      ?A ?R ?S ?T
                      ?I ?E ?N ?G ?M
                      ?Q ?W ?C ?P ?\"
                      ?O ?U ?L ?Z ?J
                      ?X ?V ?F ?D ?H
                      ?K ?B ?: ?<
                      ?> ??
                      ?@)))
#+END_SRC
** Info mode configuration
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 19:05]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! info
  (map! :map Info-mode-map
        "o" #'link-hint-open-link)
  (evil-set-initial-state 'Info-mode 'emacs))
#+END_SRC
** Ace window configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ace-window
  (setq aw-keys '(97 114 115 116 105 101 110 103 109 113 119 99
                     112 39 121 117 108 122 106 120 118 102 100 104 107 98 44 46 47
                     48 49 50 51 52 53 54 55 56 57 59 61 45 92 91 93 96 65 82 83 84
                     73 69 78 71 77 81 87 67 80 34 79 85 76 90 74 88 86 70 68 72 75
                     66 58 60 62 63 64)
        aw-dispatch-always nil
        aw-background t
        aw-overlays-back nil)
  (add-to-list 'aw-ignored-buffers "*Agda information*"))
#+END_SRC
** Display eldoc hint in child-frame at point
*** Lazy-load
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! eldoc-box
  :hook (eldoc-mode . eldoc-box-hover-at-point-mode)
  :config
  (setq eldoc-idle-delay 1)
  (when (bound-and-true-p exwm--connection)
    (add-to-list 'eldoc-box-frame-parameters '(parent-frame nil))
    (eldoc-box-hover-at-point-mode -1)
    (eldoc-box-hover-at-point-mode +1)))
#+END_SRC
** Lisp editing
*** Evil + Lispy glue
#+BEGIN_SRC emacs-lisp :tangle yes
(when (and (featurep! :editor lispy)
           (featurep! :editor evil))
  (after! lispyville
    (lispyville-set-key-theme
     '(operators
       c-w
       commentary
       prettify))
    (setq lispyville-motions-put-into-special nil)
    (map! :map lispyville-mode-map
          :nmvie "<S-right>" #'lispyville-forward-atom-end
          :nmvie "<S-left>" #'lispyville-backward-atom-begin)))
#+END_SRC
*** Lispy configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor lispy)
  (customize-set-variable 'lispy-key-theme '(special lispy))
  (after! lispy
    (setq lispy-eval-display-style 'overlay
          lispy-no-permanent-semantic t)))
#+END_SRC
** Never expire passwords
#+BEGIN_SRC emacs-lisp :tangle yes
(after! password-cache
  (setq password-cache-expiry nil))
(after! mml2015
  (setq mml-secure-passphrase-cache-expiry most-positive-fixnum))
(after! auth-source
  (setq auth-source-cache-expiry nil))
#+END_SRC
** Pinentry
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! pinentry
  :defer nil
  :config
  (defun pinentry-emacs (desc prompt ok error)
    (let ((str (read-passwd (concat (replace-regexp-in-string "%22" "\"" (replace-regexp-in-string "%0A" "\n" desc)) prompt ": "))))
      str))
  (pinentry-start))
#+END_SRC
** Abbrevs
*** Unsorted configurations
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! abbrev
  :hook ((prog-mode . abbrev-mode)
         (text-mode . abbrev-mode))
  :custom
  (abbrev-file-name (expand-file-name "abbrev_defs" doom-private-dir))
  (save-abbrevs 'silently)
  :config
  (defun save-abbrevs-or-buffer (arg)
    (interactive "p")
    (if (eq major-mode 'edit-abbrevs-mode)
        (progn (abbrev-edit-save-buffer)
               (unless arg (bury-buffer)))
      (save-buffer)))

  (defun abbrev-unignore-case-advice (oldfun &rest args)
    (let ((result (apply oldfun args)))
      (when (string-equal (car result) (cadr result))
        result)))

  (advice-add #'abbrev--before-point :around #'abbrev-unignore-case-advice)

  (when (file-exists-p abbrev-file-name)
    (quietly-read-abbrev-file))

  (map! (:leader :prefix "t"
          :desc "save file" :nmv "r" #'save-abbrevs-or-buffer))
  (map! :leader :prefix "r"
        :desc "edit abbrevs" :nmv "a" #'edit-abbrevs)

  (abbrev-table-put global-abbrev-table :case-fixed t)
  (after! nix-mode
    (abbrev-table-put nix-mode-abbrev-table :case-fixed t)))
#+END_SRC
*** Enable abbrevs in minibuffer eval
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 16:15]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'minibuffer-setup-hook
          (lambda (&rest _)
            (when (eq this-command 'eval-expression)
              (abbrev-mode))))
#+END_SRC

#+RESULTS:
| (lambda (&rest _) (when (eq this-command 'eval-expression) (abbrev-mode))) | doom-init-smartparens-in-minibuffer-maybe-h | savehist-minibuffer-hook | exwm-input--on-minibuffer-setup | winner-save-unconditionally | +doom-disable-fringes-in-minibuffer-h | cursor-intangible-mode | rfn-eshadow-setup-minibuffer | minibuffer-history-isearch-setup | minibuffer-history-initialize | exwm-layout--on-minibuffer-setup |

** Arduino mode
#+BEGIN_SRC emacs-lisp :tangle yes
(autoload 'arduino-mode "arduino-mode" "Major mode for editing Arduino code." t)
(add-to-list 'auto-mode-alist '("\\.ino\\'" . arduino-mode))
#+END_SRC
** Lispify eldoc message
#+BEGIN_SRC emacs-lisp :tangle yes
(defun jens/lispify-eldoc-message (eldoc-msg)
  "Change the format of eldoc messages for functions to `(fn args)'."
  (if (and eldoc-msg
           (member major-mode sp-lisp-modes))
      (let* ((parts (s-split ": " eldoc-msg))
             (sym (car parts))
             (args (cadr parts)))
        (cond
         ((string= args "()") (format "(%s)" sym))
         (t (format "(%s %s)" sym (substring args 1 (- (length args) 1))))))
    eldoc-msg))

(advice-add #' elisp-get-fnsym-args-string :filter-return #'jens/lispify-eldoc-message)
#+END_SRC
** Setup notification style
#+BEGIN_SRC emacs-lisp :tangle yes
(after! alert
  (setq alert-default-style 'libnotify))
#+END_SRC
** Show command frequency
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! keyfreq
  :defer nil
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC
** Automatic capitalization
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! auto-capitalize
  :defer t
  :commands (auto-capitalize-mode
             turn-on-auto-capitalize-mode))
#+END_SRC
** Deadgrep
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! deadgrep
  :defer-incrementally t
  :commands (deadgrep)
  :bind ((:map doom-leader-map
           ("f /" . deadgrep)))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "deadgrep") . (nil . "Deadgrep")))))
#+END_SRC
** Sunrise Commander, a two-pane version of Dired.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! sunrise-commander
  :defer-incrementally t
  :commands (sunrise)
  :bind (:map doom-leader-map
          ("o s" . sunrise))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "sunrise") . (nil . "Sunrise Commander"))))
  :config
  (setq sr-show-file-attributes t
        sr-cursor-follows-mouse nil
        sr-show-hidden-files t)
  (define-key sr-mode-map [mouse-1] nil)
  (define-key sr-mode-map [mouse-movement] nil))
#+END_SRC
** Show if paths exist (path-check-mode)
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar path-check-font-lock-keywords
  '(("\\(/[[:alpha:]][--/_~[:alnum:]]+\\)"
     1 (if (file-exists-p (match-string 1))
           'diff-refine-added
         'diff-refine-removed)
     prepend)))

(define-minor-mode path-check-mode
  "check if paths in file exists"
  nil nil nil
  (if path-check-mode
      (font-lock-add-keywords nil path-check-font-lock-keywords)
    (font-lock-remove-keywords nil path-check-font-lock-keywords))
  (font-lock-flush))
#+END_SRC
** Debug font-lock-keywords
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! font-lock-studio
  :commands font-lock-studio)
#+END_SRC
** Spelling
*** Set up variables
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :checkers spell)
  (after! ispell
    (setq ispell-quietly nil
          ispell-dictionary "en_US"
          ispell-complete-word-dict "~/.doom.d/dict/english-words.txt"
          ispell-personal-dictionary "~/.doom.d/.aspell.en.pws"))
  (after! flyspell
    (setq flyspell-issue-message-flag t
          flyspell-abbrev-p t)))
#+END_SRC

#+RESULTS:
: t
*** Make Ispell work with Org mode
Taken from Artur Malabarba's blog, [[https://endlessparentheses.com/ispell-and-org-mode.html][Endless Parentheses.]]
:PROPERTIES:
:CREATED_TIME: [2020-01-26 Sun 12:12]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ispell
  (defun endless/org-ispell ()
    "Configure `ispell-skip-region-alist' for `org-mode'."
    (make-local-variable 'ispell-skip-region-alist)
    (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
    (add-to-list 'ispell-skip-region-alist '("~" "~"))
    (add-to-list 'ispell-skip-region-alist '("=" "="))
    (add-to-list 'ispell-skip-region-alist '("[^\\]$" "[^\\]$"))
    (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC"))
    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
    (add-to-list 'ispell-skip-region-alist '("[^\\]\\\\begin\{\\([^\\s$\\s-]+\\)\}" . "[^\\]\\\\end\{\\([^\\s$\\s-]+\\)\}")))
  (add-hook 'org-mode-hook #'endless/org-ispell))
#+END_SRC
*** Primary entry point for Ispell
This snippet was taken from Artur Malabarba's blog, [[https://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses.]]
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ispell
  (define-key ctl-x-map "\C-i"
    #'endless/ispell-word-then-abbrev)
  ;; I should disable this keybinding from anot some other way
  (after! annot
    (define-key ctl-x-map "\C-i"
      #'endless/ispell-word-then-abbrev))

  (defun endless/simple-get-word ()
    (car-safe (save-excursion (ispell-get-word nil))))

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
        (while (if (setq bef (endless/simple-get-word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil              ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
                 ;; If there's no word at point, keep looking
                 ;; until `bob'.
                 (not (bobp)))
          (backward-word)
          (backward-char))
        (setq aft (endless/simple-get-word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point")))))
#+END_SRC
** Annotations
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! annot
  :commands (annot-edit/add annot-remove annot-load-annotations)
  :load-path "moose/vendor"
  :defer-incrementally t
  :bind (:map doom-leader-map
          ("ia" . annot-edit/add)
          ("ix" . annot-remove)
          ("iA" . annot-add-image))
  :init
  (add-hook 'text-mode-hook '(lambda ()
                               (annot-load-annotations)))
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "annot-edit/add") . (nil . "Add annotation")))
    (add-to-list 'which-key-replacement-alist
                 '((nil . "annot-remove") . (nil . "Remove annotation")))
    (add-to-list 'which-key-replacement-alist
                 '((nil . "annot-add-image") . (nil . "Add image annotation"))))
  :config
  (defun annot-run-at-end-of-line-advice (oldfun &rest args)
    (save-excursion
      (end-of-line)
      (apply oldfun args)))
  (defun annot-remove-from-current-line-advice (oldfun &rest args)
    (save-mark-and-excursion
      (beginning-of-line)
      (push-mark)
      (end-of-line)
      (apply oldfun args)))
  (cl-loop for fn in '(annot-edit/add annot-add-image)
           do (advice-add fn :around #'annot-run-at-end-of-line-advice))
  (advice-add #'annot-remove :around #'annot-remove-from-current-line-advice)
  (setq annot-enable-fuf-support t))
#+END_SRC
** Insert junk text
*** Insert paragraphs, lists, sentences
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! lorem-ipsum
  :defer-incrementally t
  :bind (:map doom-leader-map
          ("ill" . lorem-ipsum-insert-list)
          ("ilp" . lorem-ipsum-insert-paragraphs)
          ("ils" . lorem-ipsum-insert-sentences))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '(("SPC i l" . nil) . (nil . "lorem ipsum")))
    (add-to-list 'which-key-replacement-alist
                 '(("SPC i l l" . nil) . (nil . "insert list")))
    (add-to-list 'which-key-replacement-alist
                 '(("SPC i l p" . nil) . (nil . "insert paragraph")))
    (add-to-list 'which-key-replacement-alist
                 '(("SPC i l s" . nil) . (nil . "insert sentence"))))
  :config
  (setq lorem-ipsum-paragraph-separator "\n\n"
        lorem-ipsum-sentence-separator " "))
#+END_SRC
*** Convert region to junk text
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 09:53]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(defun unpackaged/lorem-ipsum-overlay (&optional remove-p)
  "Overlay all text in current buffer with \"lorem ipsum\" text.
When REMOVE-P (interactively, with prefix), remove
overlays. Useful for taking screenshots without revealing buffer
contents."
  (interactive "P")
  (dolist (ov (overlays-in (point-min) (point-max)))
    ;; Clear existing overlays created by this function.
    (when (overlay-get ov :lorem-ipsum-overlay)
      (delete-overlay ov)))
  (unless remove-p
    (require 'lorem-ipsum)
    (let ((lorem-ipsum-words
           (cl-loop for paragraph in lorem-ipsum-text
                    append (cl-loop for sentence in paragraph
                                    append (split-string sentence (rx (or space punct))
                                                         'omit-nulls))))
          (case-fold-search nil))
      (cl-labels ((overlay-match ()
                                 (let* ((beg (match-beginning 0))
                                        (end (match-end 0))
                                        (replacement-word (lorem-word (match-string 0)))
                                        (ov (make-overlay beg end)))
                                   (when replacement-word
                                     (overlay-put ov :lorem-ipsum-overlay t)
                                     (overlay-put ov 'display replacement-word))))
                  (lorem-word (word)
                              (let* ((length (length word)))
                                (cl-loop for liw in lorem-ipsum-words
                                         when (= length (length liw))
                                         collect liw into matches
                                         finally return
                                         (when matches
                                           (apply-case word (downcase (seq-random-elt matches)))))))
                  (apply-case (source target)
                              (cl-loop for sc across-ref source
                                       for tc across-ref target
                                       when (not (string-match-p (rx lower) (char-to-string sc)))
                                       do (setf tc (string-to-char (upcase (char-to-string tc)))))
                              target))
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward (rx (1+ alpha)) nil t)
            (overlay-match)))))))

(map! :leader
      :desc "convert region" "ilr" #'unpackaged/lorem-ipsum-overlay)
#+END_SRC
** Lookup
**** Set up keymap
#+BEGIN_SRC emacs-lisp :tangle yes
(after! which-key
  (add-to-list 'which-key-replacement-alist
               '(("\\`SPC a l\\'" . nil) . (nil . "lookup"))))
#+END_SRC
**** Look up word on wordnut
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! wordnut
  :defer-incrementally t
  :bind (:map doom-leader-map
          ("alw" . wordnut-search))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "wordnut-search") . (nil . "Wordnut search"))))
  :config
  (map! :map wordnut-mode-map
        :nmv "q" #'quit-window))
#+END_SRC
**** Look up word in a thesaurus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! synosaurus
  :defer-incrementally t
  :bind (:map doom-leader-map
          ("alt" . synosaurus-lookup))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "synosaurus-lookup") . (nil . "Thesaurus"))))
  :config
  (map! :map synosaurus-list-mode-map
        :nmv "q" #'quit-window))
#+END_SRC
**** Look up word in Wikipedia
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! wiki-summary
  :defer-incrementally t
  :commands (wiki-summary wiki-summary-insert)
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "wiki-summary") . (nil . "Wikipedia lookup"))))
  :bind (:map doom-leader-map
          ("alW" . wiki-summary)))
#+END_SRC
** System
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 14:34]
:END:
*** Manage network connections
https://github.com/niklascarlsson/doom-private/blob/4d18a6429c71216762d5e423d57430ad1a08b52f/%2Bsystem.el
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! enwc
  :config
  ;; Customize settings
  (setq enwc-default-backend 'nm
        enwc-display-mode-line nil
        enwc-wireless-device "wlo1"
        enwc-wired-device "lo"
        enwc-ask-to-save-interfaces nil
        enwc-warn-if-already-setup nil
        enwc-enable-auto-scan-on-startup t)
  ;; Ensure enwc buffer is delegated to the popup system.
  (defadvice! +popup--enwc-pop-to-buffer ()
    "Use `pop-to-buffer' instead of `switch-to-buffer' to open buffer.'"
    :before #'enwc
    (pop-to-buffer "*ENWC*"))
  ;; Customize popup buffer
  (set-popup-rule! "*ENWC*" :size 0.3 :side 'bottom :select t :autosave t))
#+END_SRC
*** Manage systemd units
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 18:34]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! helm-systemd
  :bind (:map doom-leader-map
          ("a9" . helm-systemd))
  :config
  (require 'hi-lock)
  (require 'helm-bookmark)
  (setq helm-systemd-list-all t
        helm-systemd-list-not-loaded t)
  (defun my-helm-systemd-display (unit-command unit &optional isuser nodisplay)
    (with-current-buffer (get-buffer-create "Helm systemd log")
      (helm-systemd-status-mode)
      (let ((command
             (helm-systemd-systemctl-command (if isuser "--user") unit-command "--" unit)))
        (insert "\nüîú " command "\n")
        (if (or isuser (string= unit-command "status"))
            (insert  (shell-command-to-string command))
          (with-temp-buffer
            (cd "/sudo::/")
            (setq command (shell-command-to-string (concat "sudo " command))))
          (insert command)
          )
        (insert "\n")
        (end-of-buffer))
      ;;    (propertise-sysd-buffer )
      (unless nodisplay
        (display-buffer (current-buffer)))))

  (advice-add #'helm-systemd-display :override #'my-helm-systemd-display))
#+END_SRC
*** TODO Proced
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 14:40]
:END:
*** TODO bluetooth
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 14:40]
:END:
** Miscellaneous applications
*** Listen to music
**** EMMS lazy-loading
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
(use-package! emms
  :bind (:map doom-leader-map
          ("a2" . emms))
  :commands (emms
             emms-play-dired)
  :defer-incrementally t
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "emms") . (nil . "Music"))))
  :config
  (require 'emms-setup)
  (emms-all)
  <<emms-defuns>>
  <<emms-config>>)
#+END_SRC
**** Function definitions
#+NAME: emms-defuns
#+BEGIN_SRC emacs-lisp :tangle no
(defun ambrevar/emms-track-description-with-album (track)
  "Simple function to give a user-readable description of a track.
If it's a file track, just return the file name.  Otherwise,
return the type and the name with a colon in between.
Hex-encoded characters in URLs are replaced by the decoded
character."
  (let ((type (emms-track-type track)))
    (cond ((eq 'file type)
           (cl-flet ((fmt (string &optional suffix prefix)
                          (if string
                              (concat prefix string suffix)
                            "")))
             (concat
              (fmt (emms-track-get track 'info-artist) " - ")
              (fmt (emms-track-get track 'info-album) " - ")
              (fmt (emms-track-get track 'info-discnumber) "/")
              (if (emms-track-get track 'info-tracknumber)
                  (format "%02d. " (string-to-number (emms-track-get track 'info-tracknumber)))
                "")
              (emms-track-get track 'info-title)
              (fmt (ambrevar/emms-time-for-display track) "]" " ["))))
          ((eq 'url type)
           (emms-format-url-track-name (emms-track-name track)))
          (t (concat (symbol-name type)
                     ": " (emms-track-name track))))))

(defun ambrevar/emms-time-for-display (track)
  "Inspired by `emms-playing-time-display'."
  (let* ((total-playing-time
          (or (emms-track-get
               track
               'info-playing-time)
              0))
         (total-min-only (/ total-playing-time 60))
         (total-sec-only (% total-playing-time 60)))
    (format "%02d:%02d" total-min-only total-sec-only)))

(defun ambrevar/emms-play-on-add (old-pos)
  "Play tracks when calling `emms-browser-add-tracks' if nothing
is currently playing."
  (interactive)
  (when (or (not emms-player-playing-p)
            emms-player-paused-p
            emms-player-stopped-p)
    (with-current-emms-playlist
      (goto-char old-pos)
      ;; if we're sitting on a group name, move forward
      (unless (emms-playlist-track-at (point))
        (emms-playlist-next))
      (emms-playlist-select (point)))
    (emms-stop)
    (emms-start)))

(defun track-description (track)
  "Return a description of the current TRACK."
  (if (and (emms-track-get track 'info-artist)
           (emms-track-get track 'info-title))
      (let ((pmin (emms-track-get track 'info-playing-time-min))
            (psec (emms-track-get track 'info-playing-time-sec))
            (ptot (emms-track-get track 'info-playing-time))
            (art  (emms-track-get track 'info-artist))
            (tit  (emms-track-get track 'info-title))
            (alb  (emms-track-get track 'info-album)))
        (cond ((and pmin psec) (format "%s - %s - %s" art alb tit))
              (ptot (format  "%s - %s - %s" art alb tit ))
              (t (emms-track-simple-description track))))
    (emms-track-simple-description track)))

(defun ambrevar/emms-browser-track-artist-and-title-format (bdata fmt)
  (concat
   "%i"
   (let ((disc (emms-browser-format-elem fmt "D")))
     (if (and disc (not (string= disc "")))
         "%D/"))
   (let ((track (emms-browser-format-elem fmt "T")))
     (if (and track (not (string= track "0")))
         "%T. "
       ""))
   "%n"))
#+END_SRC
**** Setup EMMS configuration
#+NAME: emms-config
#+BEGIN_SRC emacs-lisp :tangle no
(setq emms-directory "~/.doom.d/emms")
(setq emms-browser-info-title-format 'ambrevar/emms-browser-track-artist-and-title-format)
(setq emms-playlist-default-major-mode 'emms-playlist-mode)
(add-to-list 'emms-track-initialize-functions 'emms-info-initialize-track)

(setq later-do-interval 0.01
      later-do-batch 1)

(setq emms-source-file-directory-tree-function #'emms-source-file-directory-tree-find)
(setq emms-source-file-default-directory "~/hdd/unindexed-music")
(setq emms-player-mpd-music-directory "~/hdd/music")

(setq emms-playlist-buffer-name "Music-EMMS")

(when (executable-find "emms-print-metadata")
  (require 'emms-info-libtag)
  (add-to-list 'emms-info-functions 'emms-info-libtag))

(setq emms-info-asynchronously t)

(setq emms-track-description-function #'ambrevar/emms-track-description-with-album)

(setq emms-repeat-playlist t
      emms-stream-repeat-p t)
(setq emms-browser-covers 'emms-browser-cache-thumbnail)

(add-hook 'emms-browser-tracks-added-hook #'ambrevar/emms-play-on-add)
(setq emms-volume-change-function #'emms-volume-pulse-change)
(setq emms-volume-mode-timeout 0)
(setq emms-volume-change-amount 2)

(setq emms-browser-make-filter "all-files")
(setq emms-browser-filter-only-type 'file)
(setq emms-browser-covers #'emms-browser-cache-thumbnail-async)


(emms-lyrics 1)
(emms-score 1)
(emms-history-load)
(emms-default-players)
#+END_SRC
**** Play music from Dired
#+BEGIN_SRC emacs-lisp :tangle yes
(after! dired-x
  (add-to-list 'dired-guess-shell-alist-user
               (list "\\.\\(flac\\|mp3\\|ogg\\|wav\\|opus\\)\\'"
                     '(if (y-or-n-p "Add to emms playlist?")
                          (progn (emms-add-file (dired-get-filename))
                                 (keyboard-quit))
                        "mpv"))))
#+END_SRC
**** Search library with helm
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! helm-emms
  :bind ((:map doom-leader-map
           ("a/" . helm-emms)))
  :defer-incrementally t
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "helm-emms") . (nil . "Search music"))))
  :config
  (setq helm-emms-dired-directories (list (expand-file-name "~/hdd/unindexed-music/"))
        helm-emms-use-track-description-function t
        helm-emms-directory-files-recursive-fn #'helm-emms-walk-directory-with-find
        helm-emms-default-sources '(helm-source-emms-dired
                                    helm-source-emms-files
                                    ;;helm-source-emms-streams
                                    )))
#+END_SRC
**** Show track information in mode line
#+BEGIN_SRC emacs-lisp :tangle yes
(after! emms
  (require 'emms-mode-line-cycle)
  (require 'emms-mode-line-icon)

  (emms-mode-line 1)
  (emms-playing-time 1)

  ;; (emms-lyrics-mode-line)
  (emms-mode-line-cycle 1)

  (custom-set-variables
   '(emms-mode-line-cycle-max-width 30)
   '(emms-mode-line-cycle-additional-space-num 2)
   '(emms-mode-line-cycle-use-icon-p nil)
   '(emms-mode-line-format " [%s]")
   '(emms-mode-line-cycle-any-width-p t)
   '(emms-mode-line-cycle-velocity 2)
   '(emms-mode-line-cycle-current-title-function
     (lambda ()
       (substring-no-properties (let ((track (emms-playlist-current-selected-track)))
                                  (cl-case (emms-track-type track)
                                    ((streamlist)
                                     (let ((stream-name (emms-stream-name
                                                         (emms-track-get track 'metadata))))
                                       (if stream-name stream-name (emms-track-description track))))
                                    ((url) (emms-track-description track))
                                    (t (file-name-nondirectory
                                        (emms-track-description track)))))
                                nil -8)
       ))
   '(emms-mode-line-titlebar-function nil)))
#+END_SRC
**** Evil keybindings
:PROPERTIES:
:CREATED_TIME: [2020-01-23 Thu 10:03]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor evil)
  (map! :map emms-playlist-mode-map
        :n "q" #'bury-buffer))
#+END_SRC

*** TODO Read stackoverflow
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:03]
:END:
https://github.com/alphapapa/emacs-howdoyou
*** Manage VirtualBox sessions
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 17:26]
:END:
https://github.com/tangxinfa/counsel-virtualbox/blob/master/counsel-virtualbox.el
**** Set up counsel-virtualbox package
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ivy
  (ivy-set-actions
   'counsel-virtualbox
   `(("r" counsel-virtualbox-action-run "run")
     ("s" counsel-virtualbox-action-save "save")
     ("p" counsel-virtualbox-action-power-off "power off")
     ("n" ,(lambda (x) (kill-new (second x))) "copy name")
     ("g" ,(lambda (x) (kill-new (third x))) "copy guest os")))

  (defface counsel-virtualbox-name
    '((t :inherit font-lock-variable-name-face))
    "Face used by `counsel-virtualbox' for names."
    :group 'ivy-faces)

  (defface counsel-virtualbox-guest-os
    '((t :inherit font-lock-comment-face))
    "Face used by `counsel-virtualbox' for guest os."
    :group 'ivy-faces)

  (defface counsel-virtualbox-state-running
    '((t :inherit success))
    "Face used by `counsel-virtualbox' for running state."
    :group 'ivy-faces)

  (defface counsel-virtualbox-state-saved
    '((t :inherit font-lock-constant-face))
    "Face used by `counsel-virtualbox' for saved state."
    :group 'ivy-faces)

  (defface counsel-virtualbox-state-aborted
    '((t :inherit error))
    "Face used by `counsel-virtualbox' for aborted state."
    :group 'ivy-faces)

  (defface counsel-virtualbox-state-powered-off
    '((t :inherit font-lock-comment-face))
    "Face used by `counsel-virtualbox' for powered off state."
    :group 'ivy-faces)

  (defface counsel-virtualbox-state-other
    '((t :inherit warning))
    "Face used by `counsel-virtualbox' for other states."
    :group 'ivy-faces)

  (defun counsel--virtualbox-run (name)
    "Run virtualbox by NAME."
    (message "Run virtualbox %s" (propertize name 'face 'counsel-virtualbox-name))
    (call-process-shell-command (concat "VBoxSDL --startvm '" name "' &") nil 0))

  (defun counsel--virtualbox-save (name)
    "Save virtualbox by NAME."
    (message "Save virtualbox %s" (propertize name 'face 'counsel-virtualbox-name))
    (call-process-shell-command (concat "VBoxManage controlvm '" name "' savestate &") nil 0))

  (defun counsel--virtualbox-power-off (name)
    "Power off virtualbox by NAME."
    (message "Power off virtualbox %s" (propertize name 'face 'counsel-virtualbox-name))
    (call-process-shell-command (concat "VBoxManage controlvm '" name "' poweroff &") nil 0))

  (defun counsel--virtualbox-state-face (state)
    "Get face by STATE."
    (pcase state
      ("running" 'counsel-virtualbox-state-running)
      ("saved" 'counsel-virtualbox-state-saved)
      ("powered off" 'counsel-virtualbox-state-powered-off)
      ("aborted" 'counsel-virtualbox-state-aborted)
      (_ 'counsel-virtualbox-state-other)))

  (defun counsel-virtualbox-action (x)
    "Action on candidate X."
    (let ((name (second x))
          (state (fourth x)))
      (pcase state
        ("running" (counsel--virtualbox-save name))
        ("saved" (counsel--virtualbox-run name))
        ("powered off" (counsel--virtualbox-run name))
        ("aborted" (counsel--virtualbox-run name))
        (_ (message "No action taken on %s virtualbox %s"
                    (propertize state 'face (counsel--virtualbox-state-face state))
                    (propertize name 'face 'counsel-virtualbox-name))))))

  (defun counsel-virtualbox-action-run (x)
    "Run on candidate X."
    (counsel--virtualbox-run (second x)))

  (defun counsel-virtualbox-action-save (x)
    "Save on candidate X."
    (counsel--virtualbox-save (second x)))

  (defun counsel-virtualbox-action-power-off (x)
    "Power off on candidate X."
    (counsel--virtualbox-power-off (second x)))

  (defun counsel--virtualbox-candidates ()
    "Return list of `counsel-virtualbox' candidates."
    (with-temp-buffer
      (insert (shell-command-to-string "VBoxManage list -l vms"))
      (let ((case-fold-search t)
            candidates
            state
            guest-os
            name)
        (while (re-search-backward "^State:\s*\\(.*\\)\s*(.*" nil t)
          (setq state (string-trim (match-string 1)))
          (if (re-search-backward "^Guest OS:\s*\\(.*\\)" nil t)
              (setq guest-os (string-trim (match-string 1)))
            (signal 'error (list "Parsing virtualbox from output"
                                 "No Guest OS found"
                                 (buffer-string))))
          (if (re-search-backward "^Name:\s*\\(.*\\)" nil t)
              (setq name (string-trim (match-string 1)))
            (signal 'error (list "Parsing virtualbox from output"
                                 "No Name found"
                                 (buffer-string))))
          (push (list
                 (format "%-30s %-40s %s"
                         (propertize name 'face 'counsel-virtualbox-name)
                         (propertize guest-os 'face 'counsel-virtualbox-guest-os)
                         (propertize state 'face (counsel--virtualbox-state-face state)))
                 name
                 guest-os
                 state)
                candidates))
        candidates)))
  (counsel--virtualbox-candidates)

  (defun counsel-virtualbox ()
    "Complete VirtualBox with Ivy."
    (interactive)
    (ivy-read "virtualbox: " (counsel--virtualbox-candidates)
              :history 'counsel-virtualbox-history
              :action #'counsel-virtualbox-action
              :caller 'counsel-virtualbox
              :require-match t)))
#+END_SRC
**** Install keybinding
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 18:03]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(map! :after ivy
      :leader
      :desc "Virtual Box" "av" #'counsel-virtualbox)
#+END_SRC
*** Browse the web in w3m
**** Lazy load
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! w3m
  :defer-incrementally t
  :bind (:map doom-leader-map
          ("a3" . +w3m))
  :init
  :config
  (load (expand-file-name "w3m-type-ahead" doom-private-dir))
  (add-hook 'w3m-mode-hook #'w3m-type-ahead-mode))
#+END_SRC
**** Set up w3m workspace creation
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar +w3m-workspace-name "*w3m*")
(defvar +w3m--old-wconf nil)

(add-hook 'w3m-mode-hook #'+w3m-init-h)

(defun +w3m ()
  (interactive)
  (if (featurep! :ui workspaces)
      (+workspace-switch +w3m-workspace-name t)
    (setq +w3m--old-wconf (current-window-configuration))
    (delete-other-windows)
    (switch-to-buffer (doom-fallback-buffer)))
  (if (buffer-live-p (get-buffer "*w3m*"))
      (w3m)
    (call-interactively #'w3m-goto-url)))

(defun +w3m-init-h ()
  (add-hook 'kill-buffer-hook #'+w3m-kill-w3m-h nil t))

(defun +w3m-kill-w3m-h ()
  (cond
   ((and (featurep! :ui workspaces) (+workspace-exists-p +w3m-workspace-name))
    (+workspace/delete +w3m-workspace-name))

   (+w3m--old-wconf
    (set-window-configuration +w3m--old-wconf)
    (setq +w3m--old-wconf nil))))
#+END_SRC

#+RESULTS:
: +w3m-kill-w3m-h

**** Set w3m to emacs state
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor evil)
  (add-hook 'w3m-mode-hook #'evil-emacs-state))
#+END_SRC
**** Switch to last workspace with "q"
#+BEGIN_SRC emacs-lisp :tangle yes
(after! w3m
  (define-key w3m-mode-map (kbl-kbd "q") #'+workspace/other))
#+END_SRC
*** Watch Youtube videos
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! ivy-youtube
  :bind (:map doom-leader-map
          ("ay" . ivy-youtube-music)
          ;; ("sy" . ivy-youtube)
          )
  :defer-incrementally t
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "ivy-youtube") . (nil . "Search youtube"))))
  :config
  (defvar ivy-youtube-dl-process nil)
  (defvar ivy-youtube-music-only? nil)

  (defsubst ivy-youtube-dl-music-command (video-url)
    (list (executable-find "youtube-dl")
          "--extract-audio"
          "-f"
          "bestaudio"
          "-k"
          "-o"
          "/home/tony/hdd/youtube/%(title)s.%(ext)s"
          video-url))

  (defun ivy-youtube-play-on-process (video-url)
    "Start a process based on ivy-youtube-play-at variable passing VIDEO-URL."
    (message (format "Starting a process with: [%s %s]" ivy-youtube-play-at video-url))
    (setq ivy-youtube-dl-process
          (make-process :name "Ivy Youtube"
                        :buffer "*Ivy Youtube Output*"
                        :sentinel (lambda (process event)
                                    (message
                                     (format "Ivy Youtube: Process %s (Check buffer *Ivy Youtube Output*)" event)))
                        :command (if ivy-youtube-music-only?
                                     (ivy-youtube-dl-music-command video-url)
                                   (list ivy-youtube-play-at video-url))))
    (when ivy-youtube-music-only?
      (set-process-sentinel ivy-youtube-dl-process
                            #'ivy-youtube-dl-msg)))

  (defun ivy-youtube-dl-msg (&rest args)
    (with-current-buffer "*Ivy Youtube Output*"
      (require 'emms)
      (emms-play-file
       (progn (end-of-buffer)
              (buffer-substring-no-properties
               (1- (point))
               (progn (forward-char -1)
                      (beginning-of-line)
                      (search-forward "/home/" nil t)
                      (forward-char (- (length "/home/")))
                      (point))))))
    (setq ivy-youtube-music-only? nil))

  (defun ivy-youtube-music ()
    (interactive)
    (setq ivy-youtube-music-only? t)
    (when (and (processp emms-player-mpv-proc)
               (process-live-p emms-player-mpv-proc))
      (kill-process emms-player-mpv-proc))
    (call-interactively #'ivy-youtube))

  ;; Set Youtube API key
  (load (expand-file-name "ivy-youtube" doom-private-dir))

  (setq ivy-youtube-play-at (executable-find "mpv")))
#+END_SRC
*** COMMENT Gnus
**** Lazy loading
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! gnus
  :bind (:map doom-leader-map
          ("an" . gnus))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "gnus") . (nil . "News"))))
  :config
  (require 'smtpmail)
  (require 'gnus)
  (require 'gnus-msg)
  (require 'gnus-score)
  (require 'gnus-start)
  (require 'gnus-async))
#+END_SRC
**** Rest of configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(after! gnus
  (setq gnus-asynchronous t
        gnus-plugged nil)
  (setq gnus-use-full-window nil
        gnus-inhibit-startup-message t
        gnus-add-to-list t
        gnus-always-read-dribble-file t
        gnus-interactive-exit nil
        gnus-save-newsrc-file nil
        gnus-inhibit-user-auto-expire t
        gnus-use-scoring t
                                        ; gnus-use-trees nil
        gnus-summary-default-score 0
        gnus-summary-expunge-below -256
        gnus-summary-make-false-root 'dummy
        gnus-suppress-duplicates t
        gnus-score-expiry-days nil
        gnus-fetch-old-headers t
        gnus-home-score-file "~/.mail/gnus.score"
        gnus-agent-directory "~/.mail/agent/"
        gnus-directory "~/.mail/news"
        gnus-article-save-directory "~/.mail/news"
        gnus-cache-dictory "~/.mail/news/cache"
        gnus-cache-active-file "~/.mail/news/cache/active"
        gnus-kill-files-directory "~/.mail/news"
        nndraft-directory "~/.mail/drafts/"
        gnus-default-article-saver 'gnus-summary-save-in-mail
        gnus-save-killed-list nil
                                        ;gnus-auto-expirable-newsgroups "gmane.*"
        gnus-ignored-mime-types '("text/x-gnus")
        ;; vcard-ignored-from-addresses
        gnus-show-all-headers nil
        gnus-treat-capitalize-sentences nil
        gnus-treat-display-picons nil ;not bound?
        gnus-treat-display-smileys nil
        gnus-treat-display-x-face t
        gnus-treat-emphasize nil
        gnus-treat-fill-long-lines nil
        gnus-treat-hide-signature nil
                                        ;qgnus-treat-hide-citation t
        gnus-treat-overstrike nil
        gnus-treat-play-sounds nil ;not bound?
        gnus-treat-strip-banner nil
        gnus-treat-strip-cr t
        gnus-treat-strip-leading-blank-lines nil
        gnus-treat-strip-multiple-blank-lines nil
        gnus-treat-strip-pem nil
        gnus-treat-strip-trailing-blank-lines nil
        gnus-treat-translate nil ;not bound?
        )
  (setq gnus-inhibit-images nil
        ;; mm-discouraged-alternatives '("text/html" "text/richtext")
        )

  ;; Show the article headers in this order.
  (setq gnus-sorted-header-list
        '("^From:" "^Reply-To" "^Organization:" "^To:" "^Cc:" "^Newsgroups:"
          "^Subject:" "^Date:" "^Gnus"))

  (setq gnus-visible-headers
        "^From:\\|^Reply-To\\|^Organization:\\|^To:\\|^Cc:\\|^Newsgroups:\\|^Subject:\\|^Date:\\|^Gnus")

  (setq ;gnus-sorted-header-list gnus-visible-headers
   gnus-extra-headers
   '(To Cc Keywords Gcc Newsgroups X-Spam-Flag)
   gnus-extra-headers
   nnmail-extra-headers)
  (setq message-generate-headers-first t
        message-insert-canlock nil
        message-wash-forwarded-subjects t
        message-make-forward-subject-function #'message-forward-subject-fwd
        message-use-mail-followup-to 'use
        message-subscribed-address-functions '(gnus-find-subscribed-addresses))
  ;; (setq mail-source-delete-incoming t)

  (setq nnmail-split-methods 'nnmail-split-fancy
        nnmail-split-header-length-limit 4096
        nnmail-use-long-file-names t
        nnmail-crosspost nil)

  ;; (setq gnus-select-method '(nntp "news.gwene.org")) ;; Read feeds/atom through gwene
  (setq gnus-select-method
        '(nntp "news.gmane.org"
               (nntp-open-connection-function nntp-open-plain-stream)))
  (setq gnus-secondary-select-methods '((nntp "nntp.aioe.org")
                                        (nnmaildir "outlook"
                                                   (directory "~/.mail/outlook"))
                                        (nntp "news.eternal-september.org")
                                        (nntp "news.gwene.org")
                                        ;; (nnreddit "")
                                        ;; (nnml "")
                                        ))

  (setq gnus-message-archive-method
        '(nnfolder "archive"
                   (nnfolder-directory    "~/.mail/outlook/Archive")
                   (nnfolder-active-file  "~/.mail/outlook/Archive/active")
                   (nnfolder-get-new-mail nil)))

  ;; Crypt-foo
  (setq gnus-message-replysign t
        gnus-message-replyencrypt t
        mm-verify-option 'always
        mm-decrypt-option 'always)

  ;; (define-key message-minibuffer-local-map [(tab)] 'bbdb-complete-name)

  ;; Buttonize the different parts, please
  (setq gnus-buttonized-mime-types '("multipart/encrypted" "multipart/signed"))

  ;; But keep buttons for multiple parts
  (setq gnus-inhibit-mime-unbuttonizing t)

  ;; ask encryption password once
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)

  (setq gnus-thread-sort-functions
        '(gnus-thread-sort-by-most-recent-date
          (not gnus-thread-sort-by-number)))

                                        ; NO 'passive
  (setq gnus-use-cache t)

  ;; press "o" to view all groups
  (defun my-gnus-group-list-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 5))

  (define-key gnus-group-mode-map
    ;; list all the subscribed groups even they contain zero un-read messages
    (kbd "o") 'my-gnus-group-list-subscribed-groups)

  ;; Fetch only part of the article if we can.
  ;; I saw this in someone's .gnus
  (setq gnus-read-active-file 'some)

  ;; open attachment
  (eval-after-load 'mailcap
    '(progn
       (cond
        ;; on macOS, maybe change mailcap-mime-data?
        ((eq system-type 'darwin))
        ;; on Windows, maybe change mailcap-mime-data?
        ((eq system-type 'windows-nt))
        (t
         ;; Linux, read ~/.mailcap
         (mailcap-parse-mailcaps)))))

  ;; Tree view for groups.
  (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

  ;; Threads!  I hate reading un-threaded email -- especially mailing
  ;; lists.  This helps a ton!
  (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)

  ;; Also, I prefer to see only the top level message.  If a message has
  ;; several replies or is part of a thread, only show the first message.
  ;; `gnus-thread-ignore-subject' will ignore the subject and
  ;; look at 'In-Reply-To:' and 'References:' headers.
  (setq gnus-thread-hide-subtree t)
  (setq gnus-thread-ignore-subject t)

  ;; Read HTML mail:
  ;; You need install the command line web browser 'w3m' and Emacs plugin 'w3m'
  ;; manually. It specify the html render as w3m so my setup works on all versions
  ;; of Emacs.
  ;;
  ;; Since Emacs 24+, a default html rendering engine `shr' is provided:
  ;;   - It works out of box without any cli program dependency or setup
  ;;   - It can render html color
  ;; So below line is optional.
  (setq mm-text-html-renderer 'w3m) ; OPTIONAL

  ;; Send email through SMTP
  (setq message-send-mail-function #'smtpmail-send-it
        send-mail-function #'smtpmail-send-it
        smtpmail-queue-dir "~/.mail/queued-mail/"
        smtpmail-debug-info t)

  (setq smtpmail-stream-type 'starttls
        smtpmail-starttls-credentials `((,user-mail-address 25 nil nil))
        smtpmail-default-smtp-server "smtp.office365.com"
        smtpmail-smtp-server "smtp.office365.com"
        smtpmail-smtp-service 25)

  ;; http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
  (setq gnus-use-correct-string-widths nil)

  ;; Sample on how to organize mail folders.
  ;; It's dependent on `gnus-topic-mode'.
  ;; (eval-after-load 'gnus-topic
  ;;   '(progn
  ;;      (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
  ;;      (setq gnus-server-alist '(("Archive" nnfolder "Archive"
  ;;                                 (nnfolder-directory "~/.mail/Archive")
  ;;                                 (nnfolder-active-file "~/.mail/Archive/active")
  ;;                                 (nnfolder-get-new-mail nil)
  ;;                                 (nnfolder-inhibit-expiry t))))

  ;;      ;; "Gnus" is the root folder, and there are three mail accounts, "misc", "hotmail", "gmail"
  ;;      (setq gnus-topic-topology '(("Gnus" visible)
  ;;                                  ;; (("misc" visible))
  ;;                                  (("outlook" visible nil nil))))

  ;;      ;; each topic corresponds to a public imap folder
  ;;      (setq gnus-topic-alist '(("outlook" ; the key of topic
  ;;                                "nnimap+outlook:Inbox"
  ;;                                "nnimap+outlook:Drafts"
  ;;                                "nnimap+outlook:Sent"
  ;;                                ;;"nnimap+outlook:Junk"
  ;;                                ;;"nnimap+outlook:Deleted"
  ;;                                )
  ;;                               ;; ("misc" ; the key of topic
  ;;                               ;;  "nnfolder+archive:sent.2018"
  ;;                               ;;  "nnfolder+archive:sent.2019"
  ;;                               ;;  "nndraft:drafts")
  ;;                               ("Gnus")))))

  ;; eye candy
  (with-eval-after-load "gnus"
    (copy-face 'font-lock-variable-name-face 'gnus-face-6)
    (setq gnus-face-6 'gnus-face-6)
    (copy-face 'font-lock-constant-face 'gnus-face-7)
    (setq gnus-face-7 'gnus-face-7)
    (copy-face 'gnus-face-7 'gnus-summary-normal-unread)
    (copy-face 'font-lock-constant-face 'gnus-face-8)
    (set-face-foreground 'gnus-face-8 "gray50")
    (setq gnus-face-8 'gnus-face-8)
    (copy-face 'font-lock-constant-face 'gnus-face-9)
    (set-face-foreground 'gnus-face-9 "gray70")
    (setq gnus-face-9 'gnus-face-9)
    (setq gnus-summary-make-false-root 'dummy)
    (setq gnus-summary-make-false-root-always nil)

    (defun oxy-unicode-threads ()
      (interactive)
      (setq gnus-summary-dummy-line-format "    %8{‚îÇ%}   %(%8{‚îÇ%}                       %7{‚îÇ%}%) %6{‚ñ°%}  %S\n"
            gnus-summary-line-format "%8{%4k‚îÇ%}%9{%U%R%z%}%8{‚îÇ%}%*%(%-23,23f%)%7{‚îÇ%} %6{%B%} %s\n"
            gnus-sum-thread-tree-indent " "
            gnus-sum-thread-tree-root "‚ñ† "
            gnus-sum-thread-tree-false-root "‚ñ° "
            gnus-sum-thread-tree-single-indent "‚ñ£ "
            gnus-sum-thread-tree-leaf-with-other "‚îú‚îÄ‚ñ∂ "
            gnus-sum-thread-tree-vertical "‚îÇ"
            gnus-sum-thread-tree-single-leaf "‚îî‚îÄ‚ñ∂ "))

    (defun oxy-unicode-threads-heavy ()
      (interactive)
      (setq gnus-summary-line-format "%8{%4k‚îÇ%}%9{%U%R%z%}%8{‚îÇ%}%*%(%-23,23f%)%7{‚ïë%} %6{%B%} %s\n"
            gnus-summary-dummy-line-format "    %8{‚îÇ%}   %(%8{‚îÇ%}                       %7{‚ïë%}%) %6{‚îè‚óã%}  %S\n"
            gnus-sum-thread-tree-indent " "
            gnus-sum-thread-tree-root "‚îè‚óè "
            gnus-sum-thread-tree-false-root " ‚óã "
            gnus-sum-thread-tree-single-indent " ‚óè "
            gnus-sum-thread-tree-leaf-with-other "‚î£‚îÅ‚îÅ‚ùØ "
            gnus-sum-thread-tree-vertical "‚îÉ"
            gnus-sum-thread-tree-single-leaf "‚îó‚îÅ‚îÅ‚ùØ "))

    (oxy-unicode-threads-heavy)))
#+END_SRC

*** rTorrent interface
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! mentor
  :defer-incrementally t
  :bind (:map doom-leader-map
          ("at" . mentor))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist '((nil . "mentor") . (nil . "rTorrent"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'mentor-mode 'emacs)))
#+END_SRC
*** Weather forecast
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! forecast
  :defer-incrementally t
  :commands forecast
  :bind (:map doom-leader-map
          ("aw" . forecast))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist '((nil . "forecast") . (nil . "Weather"))))
  :config
  (setq forecast-api-key "3952024acf85777d62f39869da12f853")
  (setq forecast-units 'us)
  (setq forecast-language 'en))
#+END_SRC
*** Community-driven man pages
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! tldr
  :commands (tldr)
  :bind (:map doom-leader-map
          ("alc" . tldr))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "tldr") . (nil . "Community-driven manpages"))))
  :config
  (setq tldr-directory-path (concat doom-etc-dir "tldr/")))
#+END_SRC
*** Typing practice
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! speed-type
  :defer-incrementally t
  :commands (speed-type-text)
  :bind (:map doom-leader-map
          ("aT" . speed-type-text))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "speed-type-text") . (nil . "Typing practice"))))
  (when (featurep! :editor evil)
    (defun +amos*evil-insert (&rest _)
      (evil-insert-state))
    (advice-add #'speed-type--setup :after #'+amos*evil-insert))
  (map!
   :map speed-type--completed-keymap
   :ni "q" #'kill-this-buffer
   :ni "r" #'speed-type--replay
   :ni "n" #'speed-type--play-next))
#+END_SRC
*** Encode a string into QR
#+BEGIN_SRC emacs-lisp :tangle yes
(defun kisaragi/qr-encode (str &optional buf)
  "Encode STR as a QR code.
Return a new buffer or BUF with the code in it."
  (interactive "MString to encode: ")
  (let ((buffer (get-buffer-create (or buf "*QR Code*")))
        (format (if (display-graphic-p) "PNG" "UTF8"))
        (inhibit-read-only t))
    (with-current-buffer buffer
      (delete-region (point-min) (point-max)))
    (make-process
     :name "qrencode" :buffer buffer
     :command `("qrencode" ,str "-t" ,format "-o" "-")
     :coding 'no-conversion
     ;; seems only the filter function is able to move point to top
     :filter (lambda (process string)
               (with-current-buffer (process-buffer process)
                 (insert string)
                 (goto-char (point-min))
                 (set-marker (process-mark process) (point))))
     :sentinel (lambda (process change)
                 (when (string= change "finished\n")
                   (with-current-buffer (process-buffer process)
                     (cond ((string= format "PNG")
                            (image-mode)
                            (image-transform-fit-to-height))
                           (t           ;(string= format "UTF8")
                            (text-mode)
                            (decode-coding-region (point-min) (point-max) 'utf-8)))))))
    (when (called-interactively-p 'interactive)
      (display-buffer buffer))
    buffer))
(after! which-key
  (add-to-list 'which-key-replacement-alist
               '((nil . "kisaragi/qr-encode") . (nil . "QR encode"))))
(map! :leader
      "aQ" #'kisaragi/qr-encode)
#+END_SRC
*** Disk Usage
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! disk-usage
  :commands disk-usage
  :bind (:map doom-leader-map
          ("ad" . disk-usage))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "disk-usage") . (nil . "Disk usage")))))
#+END_SRC
*** Speed reading
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! spray
  :defer-incrementally t
  :commands spray-mode
  :bind (:map doom-leader-map
          ("as" . spray-mode))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "spray-mode") . (nil . "Speed read"))))
  :config
  (map! :map spray-mode-map
        "i" #'spray-forward-word
        "m" #'spray-backward-word
        "n" #'spray-faster
        "e" #'spray-slower)
  (when (featurep! :editor evil)
    (add-hook 'spray-mode-hook #'evil-emacs-state)
    (advice-add #'spray-quit :after
                (lambda (&rest _)
                  (evil-normal-state)))))
#+END_SRC
*** Reddit
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! md4rd
  :defer-incrementally t
  :commands md4rd
  :bind (:map doom-leader-map
          ("ar" . md4rd))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "md4rd") . (nil . "Reddit"))))
  :config
  (map! :map md4rd-mode-map
        :n "l" #'tree-mode-goto-parent
        :n "y" #'md4rd-open
        :n "d" #'md4rd-visit
        :n "c" #'tree-mode-toggle-expand
        :n "TAB" #'tree-mode-toggle-expand
        :n "c" #'md4rd-widget-expand-all
        :n "f" #'md4rd-widget-collapse-all
        :n "k" #'widget-forward
        :n "n" #'widget-forward
        :n "m" #'backward-button
        :n "'" #'widget-backward
        :n "e" #'widget-backward
        :n "i" #'forward-button
        :n "q" #'kill-current-buffer
        :n "p" #'md4rd-reply
        :n "l" #'md4rd-upvote
        :n "s" #'md4rd-downvote
        :n "z" #'md4rd-widget-toggle-line
        :n "=" #'md4rd-indent-all-the-lines)
  (add-hook! 'md4rd-mode-hook #'md4rd-indent-all-the-lines)
  (add-to-list 'md4rd-subs-active 'nixos :append))
#+END_SRC
** Games
*** Set up prefix map
#+BEGIN_SRC emacs-lisp :tangle yes
(after! which-key
  (add-to-list 'which-key-replacement-alist
               '(("\\`SPC a g\\'" . nil) . (nil . "games"))))
#+END_SRC
*** Tetris
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! tetris
  :defer-incrementally t
  :commands tetris
  :bind (:map doom-leader-map
          ("agt" . tetris))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "tetris") . (nil . "Tetris")))))
#+END_SRC
*** Doctor
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! doctor
  :defer-incrementally t
  :commands doctor
  :bind (:map doom-leader-map
          ("agd" . doctor))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "doctor") . (nil . "Doctor"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'doctor-mode 'insert)
    (map! :map doctor-mode-map
          :n "q" #'bury-buffer)))
#+END_SRC
*** Jumblr
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! jumblr
  :defer-incrementally t
  :commands jumblr
  :bind (:map doom-leader-map
          ("agj" . jumblr))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "jumblr") . (nil . "Jumblr"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'jumblr-mode 'insert)))
#+END_SRC
*** Pong
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! pong
  :defer-incrementally t
  :commands pong
  :bind (:map doom-leader-map
          ("agp" . pong))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "pong") . (nil . "Pong")))))
#+END_SRC
*** Snake
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! snake
  :defer-incrementally t
  :commands snake
  :bind (:map doom-leader-map
          ("ags" . snake))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "snake") . (nil . "Snake"))))
  :config
  (map! :map snake-mode-map
        :nmvie "n" #'snake-move-down
        :nmvie "e" #'snake-move-up
        :nmvie "m" #'snake-move-left
        :nmvie "i" #'snake-move-right
        :nmvie "<space>" #'snake-pause-game
        :nmvie "SPC" #'snake-pause-game
        :nmvie "<backspace>" #'snake-start-game))
#+END_SRC
*** Dunnet
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! dunnet
  :defer-incrementally t
  :commands dunnet
  :bind (:map doom-leader-map
          ("agd" . dunnet))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "dunnet") . (nil . "Dunnet")))))
#+END_SRC
*** 2048
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! 2048-game
  :defer-incrementally t
  :commands 2048-game
  :bind (:map doom-leader-map
          ("ag2" . 2048-game))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "2048-game") . (nil . "2048")))))
#+END_SRC
*** 5-in-a-row
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! gomoku
  :defer-incrementally t
  :commands gomoku
  :bind (:map doom-leader-map
          ("ag%" . gomoku))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "gomoku") . (nil . "5-in-a-row")))))
#+END_SRC
*** 5x5
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! 5x5
  :defer-incrementally t
  :commands 5x5
  :bind (:map doom-leader-map
          ("ag5" . 5x5)))
#+END_SRC
*** Minesweeper
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! minesweeper
  :defer-incrementally t
  :commands minesweeper
  :bind (:map doom-leader-map
          ("agm" . minesweeper))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "minesweeper") . (nil . "Minesweeper")))))
#+END_SRC
*** Go
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! gnugo
  :defer-incrementally t
  :commands gnugo
  :bind (:map doom-leader-map
          ("agg" . gnugo))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "gnugo") . (nil . "go")))))
#+END_SRC
*** Multiplication puzzles
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! mpuz
  :defer-incrementally t
  :commands mpuz
  :bind (:map doom-leader-map
          ("agx" . mpuz))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "mpuz") . (nil . "Multiplication puzzle")))))
#+END_SRC
*** Bubbles puzzle game
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! bubbles
  :defer-incrementally t
  :commands bubbles
  :bind (:map doom-leader-map
          ("agb" . bubbles))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "bubbles") . (nil . "Bubbles")))))
#+END_SRC
*** Keybinding quizzes
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! key-quiz
  :defer-incrementally t
  :commands key-quiz
  :bind (:map doom-leader-map
          ("agk" . key-quiz))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "key-quiz") . (nil . "Keybinding quiz"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'key-quiz-mode 'emacs)))
#+END_SRC
*** Z-machine interpreter for text-based adventure games
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! malyon
  :defer-incrementally t
  :commands malyon
  :bind (:map doom-leader-map
          ("agz" . malyon))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "malyon") . (nil . "Z-machine"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'malyon-mode 'emacs)))
#+END_SRC
*** Binary & Hexadecimal conversion practice
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! binarytrainer
  :defer-incrementally t
  :commands (play-binary play-hex)
  :bind (:map doom-leader-map
          ("ag0" . play-binary)
          ("ag1" . play-hex))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "play-binary") . (nil . "Binary conversion quiz")))
    (add-to-list 'which-key-replacement-alist
                 '((nil . "play-hex") . (nil . "Hex conversion quiz"))))
  :config
  (require 'cl-format))
#+END_SRC
** Quotes
*** Set up prefix map
#+BEGIN_SRC emacs-lisp :tangle yes
(after! which-key
  (add-to-list 'which-key-replacement-alist
               '(("\\`SPC a q\\'" . nil) . (nil . "quotes"))))
#+END_SRC
*** Fortune Cookie
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! cookie1
  :commands (cookie)
  :bind (:map doom-leader-map
          ("aqc" . cookie))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "cookie") . (nil . "Fortune cookie"))))
  :config
  (setq cookie-file "~/docs/ascii/misc/fortunes/fortunes"))
#+END_SRC
*** Faith
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! faith
  :defer-incrementally t
  :commands (faith
             faith-quote
             faith-insert
             faith-correct-buffer
             faith-correct-region
             faith-correct-string)
  :bind (:map doom-leader-map
          ("aqf" . faith-quote))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "faith-quote") . (nil . "Chuch of Emacs")))))
#+END_SRC
** Eye candy
*** Set up prefix map
#+BEGIN_SRC emacs-lisp :tangle yes
(after! which-key
  (add-to-list 'which-key-replacement-alist
               '(("\\`SPC a e\\'" . nil) . (nil . "eyecandy"))))
#+END_SRC
*** TODO Snow
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 20:12]
:END:
https://github.com/alphapapa/snow.el
*** TODO Flames of freedom
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 20:12]
:END:
https://github.com/alphapapa/FlamesOfFreedom
*** Hanoi
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! hanoi
  :defer-incrementally t
  :commands (hanoi hanoi-unix hanoi-unix-64)
  :bind (:map doom-leader-map
          ("aehh" . hanoi)
          ("aehu" . hanoi-unix)
          ("aeh6" . hanoi-unix-64))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '(("\\`SPC a e h\\'" . nil) . (nil . "Hanoi")))
    (add-to-list 'which-key-replacement-alist
                 '((nil . "hanoi") . (nil . "Hanoi")))
    (add-to-list 'which-key-replacement-alist
                 '((nil . "hanoi-unix") . (nil . "Hanoi Unix")))
    (add-to-list 'which-key-replacement-alist
                 '((nil . "hanoi-unix-64") . (nil . "Hanoi Unix 64")))))
#+END_SRC
*** Dissociated press
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! dissociate
  :defer-incrementally t
  :commands dissociated-press
  :bind (:map doom-leader-map
          ("aed" . dissociated-press))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "dissociated-press") . (nil . "Dissociated press")))))
#+END_SRC
*** Life
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! life
  :defer-incrementally t
  :commands life
  :bind (:map doom-leader-map
          ("aeL" . life))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "life") . (nil . "Life"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'life-mode 'emacs)))
#+END_SRC
*** Zone
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! zone
  :defer-incrementally t
  :commands zone
  :bind (:map doom-leader-map
          ("aez" . zone))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "zone") . (nil . "Zone")))))
#+END_SRC
*** Fireplace
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! fireplace
  :defer-incrementally t
  :commands fireplace
  :bind (:map doom-leader-map
          ("aef" . fireplace))
  :init
  (after! which-key
    (add-to-list 'which-key-replacement-alist
                 '((nil . "fireplace") . (nil . "Fireplace"))))
  :config
  (when (featurep! :editor evil)
    (evil-set-initial-state 'fireplace-mode 'emacs)))
#+END_SRC
* Doom modules
** COMMENT Unicode fonts
*** Do not enable display reordering
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-unicode-init-fonts-h ()
  "Set up `unicode-fonts' to eventually run; accomodating the daemon, if
necessary."
  (setq-default bidi-display-reordering nil
                doom-unicode-font nil)
  (if initial-window-system
      (+unicode-setup-fonts-h (selected-frame))
    (add-hook 'after-make-frame-functions #'+unicode-setup-fonts-h)))

(advice-add #'+unicode-init-fonts-h :override #'my-unicode-init-fonts-h)
#+END_SRC
** Smartparens
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 07:01]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! smartparens
  (map! :eig [C-S-backspace] #'sp-backward-delete-symbol))
#+END_SRC
** Fill column
:PROPERTIES:
:CREATED_TIME: [2020-01-23 Thu 12:42]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! doom-themes
  (add-to-list 'doom-themes-base-faces
               '(hl-fill-column-face :inherit 'shadow)))
#+END_SRC
** Popups
#+BEGIN_SRC emacs-lisp :tangle yes
(after! popup
  (set-popup-rules! '(("^\\*Agda information" :size 0.3 :focus nil)
                      ("\\*intero:global-project::repl" :size 0.3 :focus t)
                      ("\\*haskell-process-log" :size 0.3 :focus nil :quit t)
                      ("\\*test\\*" :size 0.3 :focus t)
                      ("\\*Compile-Log\\*" :size 0.3 :focus nil :quit t)
                      ("^\\*Org Agenda\\*" :size 0.5 :side 'bottom)
                      ("^\\*eww\\*" :ignore t)
                      ("^\\*cfw:details\\*" :size 0.35)
                      ("URxvt" :size 0.35 :side 'bottom :focus t :quit nil)
                      ("Helm systemd" :ignore t))))
#+END_SRC
** Workspaces
:PROPERTIES:
:CREATED_TIME: [2020-01-26 Sun 08:51]
:END:
*** Keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :ui workspaces)
  (map! "C-c C-1" #'+workspace/switch-to-0
        "C-c C-2" #'+workspace/switch-to-1
        "C-c C-3" #'+workspace/switch-to-2
        "C-c C-4" #'+workspace/switch-to-3
        "C-c C-5" #'+workspace/switch-to-4
        "C-c C-6" #'+workspace/switch-to-5
        "C-c C-7" #'+workspace/switch-to-6
        "C-c C-8" #'+workspace/switch-to-7
        "C-c C-9" #'+workspace/switch-to-8
        "C-c C-0" #'+workspace/switch-to-final))
#+END_SRC

#+RESULTS:
** Eshell
:PROPERTIES:
:CREATED_TIME: [2020-01-26 Sun 21:27]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook! eshell-mode
  (eldoc-mode -1))
#+END_SRC
** Evil
*** Evil snipe
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor evil)
  (after! evil-snipe
    (setq evil-snipe-scope 'line
          evil-snipe-spillover-scope 'visible)))
#+END_SRC
*** Expand abbrevs on escape
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 08:16]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'evil-insert-state-exit-hook #'expand-abbrev)
#+END_SRC
*** Better jumper jump forward binding
:PROPERTIES:
:CREATED_TIME: [2020-01-27 Mon 10:00]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor evil)
  (when (display-graphic-p)
    (after! evil-org
      (map! :map evil-org-mode-map
            :nv "TAB" nil
            :nv "<tab>" #'org-cycle)))
  (after! lispy
    (map! :map lispy-mode-map
          [remap pop-tag-mark] #'better-jumper-jump-backward)))
#+END_SRC
*** Disable mouse selection
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 09:00]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! evil
  (advice-add 'evil-mouse-drag-region :after
              (defun $fix-miss-drag (&rest _x)
                (when (region-active-p)
                  (cl-destructuring-bind (beg . end) (car (region-bounds))
                    (when (> 4 (- end beg))
                      (evil-normal-state))))))

  (advice-add 'mouse-set-region :after 'deactivate-mark))
#+END_SRC
** Company
*** COMMENT Use posframe
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! company-posframe
  :if (posframe-workable-p)
  :hook (company-mode . company-posframe-mode)
  :config
  (setq company-posframe-quickhelp-delay (when (boundp 'company-quickhelp-delay)
                                           company-quickhelp-delay)))
#+END_SRC
*** Tune company performance
:PROPERTIES:
:CREATED_TIME: [2020-01-19 Sun 14:34]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! company
  (setq company-idle-delay 0.8
        company-minimum-prefix-length 1))
#+END_SRC
*** Show documentation tooltips in Company
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! company-quickhelp
  :after company
  :custom
  (company-quickhelp-margin 15)
  (company-quickhelp-delay nil)
  :hook (company-mode . company-quickhelp-local-mode))
#+END_SRC
*** Company Org LaTeX math
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 22:18]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun math-symbol-at-point ()
    (->> (save-excursion (buffer-substring-no-properties (or (and (re-search-backward "[\s\t\n]" (1+ (point-at-bol)) t)
                                                                  (progn (forward-char 1)
                                                                         (point)))
                                                             (point))
                                                         (or (and (re-search-forward "[\s\t\n]" (1+ (point-at-eol)) t)
                                                                  (progn (forward-char -1)
                                                                         (point)))
                                                             (point))))

         (string-remove-prefix "$")
         (string-remove-suffix "$")
         (string-remove-suffix ",")
         (string-remove-suffix ".")
         (string-remove-prefix "(")
         (string-remove-suffix ")")
         (string-remove-prefix "[")
         (string-remove-suffix "]")
         (string-remove-suffix "\\")
         (string-remove-suffix ")")
         (string-remove-suffix "]")
         ))

  (defun math-symbol-up-to-point ()
    (let ((pt (point)))
      (->> (save-excursion (buffer-substring-no-properties (or (and (re-search-backward "[\s\t]" (point-at-bol) t)
                                                                    (progn (forward-char 1)
                                                                           (point)))
                                                               (point))
                                                           pt))
           (string-remove-prefix "$")
           (string-remove-suffix "$")
           (string-remove-suffix ",")
           (string-remove-suffix ".")
           (string-remove-prefix "(")
           (string-remove-suffix ")")
           (string-remove-prefix "[")
           (string-remove-suffix "]")
           )))

  (defun math/he-try-expand-flx-regexp (str)
    "Generate regexp for flexible matching of str."
    (concat (rx word-boundary)
            str
            "[^\s\t\n]+"
            ))

  (defun math/he-try-expand-flx-collect (str)
    "Find and collect all words that flex-match str, and sort by flx score"
    (let ((coll)
          (regexp (math/he-try-expand-flx-regexp str)))
      (save-excursion
        (goto-char (point-min))
        (while (and (search-forward-regexp regexp nil t)
                    ;; (texmathp)
                    (lattie--math-p)
                    )
          (push (math-symbol-at-point) coll)
          ))
      (setq coll (remove "" coll))
      (sort coll (lambda (a b)
                   (> (car (flx-score a str))
                      (car (flx-score b str)))))
      ))

  (defun math/he-try-expand-flx (old)
    "Try to complete word using flx matching."
    (unless old
      ;; (he-init-string (he-lisp-symbol-beg) (point))
      (setq he-search-string (math-symbol-up-to-point))
      (unless (he-string-member he-search-string he-tried-table)
        (push he-search-string he-tried-table))
      (setq he-expand-list
            (unless (equal he-search-string "")
              (math/he-try-expand-flx-collect he-search-string))))
    (while (and he-expand-list
                (he-string-member (car he-expand-list) he-tried-table))
      (pop he-expand-list))
    (prog1
        (null he-expand-list)
      (if (null he-expand-list)
          (when old (he-reset-string))
        (he-substitute-string (pop he-expand-list)))))


  (defun hippie-expand-or-company-flx-math ()
    (interactive)
    (if (and (eq major-mode 'org-mode)
             (lattie--math-p))
        (call-interactively #'company-flx-math)
      (let ((c)))
      (call-interactively #'hippie-expand)))

  (global-set-key [remap hippie-expand] #'hippie-expand-or-company-flx-math)

  (defun company-flx-math (command &optional arg &rest ignored)
    (interactive (company-begin-backend 'company-flx-math))
    (cl-case command
      (prefix (when (lattie--math-p)
                (math-symbol-up-to-point)))
      (candidates (math/he-try-expand-flx-collect arg))
      ;; (meta (format "This value is named %s" arg))
      )))
#+END_SRC

*** Company active map
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 23:03]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! company
  (map! :map company-active-map
        "C-c C-1" (lambda! (company-complete-number 1))
        "C-c C-2" (lambda! (company-complete-number 2))
        "C-c C-3" (lambda! (company-complete-number 3))
        "C-c C-4" (lambda! (company-complete-number 4))
        "C-c C-5" (lambda! (company-complete-number 5))
        "C-c C-6" (lambda! (company-complete-number 6))
        "C-c C-7" (lambda! (company-complete-number 7))
        "C-c C-8" (lambda! (company-complete-number 8))
        "C-c C-9" (lambda! (company-complete-number 9))
        "C-c C-0" (lambda! (company-complete-number 10))
        ))
#+END_SRC
** LaTeX
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 19:14]
:END:
*** Math environments setup
#+BEGIN_SRC emacs-lisp :tangle yes
(after! texmathp
  (add-to-list 'texmathp-tex-commands '("tikzcd" env-on))
  (texmathp-compile))

(after! font-latex
  (add-to-list 'font-latex-math-environments "tikzcd"))
#+END_SRC
*** CDLaTeX
:PROPERTIES:
:CREATED_TIME: [2020-01-28 Tue 23:11]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! cdlatex
  (add-to-list 'cdlatex-math-modify-alist '(?a "\\mathfrak" nil t nil nil))
  (add-to-list 'cdlatex-math-modify-alist '(?l "\\mathscr" nil t nil nil))
  (add-to-list 'cdlatex-math-modify-alist '(?w "\\mathbb" nil t nil nil))
  )
#+END_SRC
** Helm
*** Prioritize Ivy over Helm
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :completion ivy)
  (advice-add #'helm-mode :around #'ignore)
  (after! org
    (map! :map org-mode-map
          :localleader
          "." #'counsel-org-goto
          "/" #'counsel-org-goto-all)))
#+END_SRC
*** COMMENT Display candidates in a childframe
:PROPERTIES:
:CREATED_TIME: [2020-01-23 Thu 20:44]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! helm
  (require 'posframe)
  (defvar helm-display-function #'helm-posframe-display)

  (defvar helm-posframe-buffer nil)

  (defun helm-posframe-display (buffer &optional _resume)
    (posframe-show
     (setq helm-posframe-buffer buffer)
     :poshandler #'posframe-poshandler-frame-bottom-left-corner
     :left-fringe 10
     :width (window-width)
     :height 20
     :respect-header-line t))

  (defun helm-posframe-cleanup ()
    (posframe-hide helm-posframe-buffer))

  (add-hook 'helm-cleanup-hook #'helm-posframe-cleanup))
#+END_SRC

#+RESULTS:
| helm-posframe-cleanup | helm-ff-save-history | helm-find-files--reset-level-tree | helm-match-line-cleanup | helm-handle-winner-boring-buffers | helm-reset-yank-point |

** Ivy
*** Preview buffers in ivy-switch-buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ivy
  (setq +ivy-buffer-preview 'everything))
#+END_SRC
*** Bind ivy-immediate-done to home-row key
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ivy
  (define-key ivy-minibuffer-map (kbl-kbd "j" 'control nil 'shift nil) #'ivy-immediate-done))
#+END_SRC
*** Allow posframe to overlap EXWM frames
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook! 'exwm-init-hook
  (after! ivy-posframe
    (add-to-list 'ivy-posframe-parameters '(parent-frame . nil))))
#+END_SRC
*** Ivy magic space
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 08:58]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! ivy
  (defun ivy-magical-space ()
    "If there is a single ivy candidate and point is at the end of the minibuffer,
exit with that candidate, otherwise insert SPACE character as usual."
    (interactive)
    (call-interactively
     (if (and (= 1 (length ivy--old-cands))
              (= (point) (line-end-position)))
         #'ivy-done
       #'self-insert-command)))

  (define-key ivy-minibuffer-map (kbd "SPC") 'ivy-magical-space))
#+END_SRC
** Dired
*** COMMENT Use ivy in ranger-travel
#+BEGIN_SRC emacs-lisp :tangle yes
(when (and (featurep! :completion ivy)
           (featurep! :emacs dired +ranger))
  (defun ranger-travel-use-ivy-advice (oldfun &rest args)
    (if (featurep 'ivy)
        (cl-letf (((symbol-function #'featurep) (lambda (x) (eq x 'ivy))))
          (apply oldfun args))
      (apply oldfun args)))

  (advice-add #'ranger-travel :around #'ranger-travel-use-ivy-advice))
#+END_SRC
*** Play music in dired
#+BEGIN_SRC emacs-lisp :tangle yes
(after! dired
  (define-key dired-mode-map (kbl-kbd "@") #'emms-play-dired)
  (after! ranger
    (define-key ranger-mode-map (kbl-kbd "@") #'emms-play-dired)))
#+END_SRC
*** COMMENT Decompress files easily in Dired
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 14:06]
:END:
https://stackoverflow.com/questions/10226836/how-to-tar-and-compress-marked-files-in-emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(after! dired
  ;; dired-a provides support functions, including archiving, for dired
  (require 'dired-a)

  ;; Alist with information how to add files to an archive (from dired-a)
  ;; Each element has the form (REGEXP ADD-CMD NEW-CMD). If REGEXP matches
  ;; the file name of a target, that target is an archive and ADD-CMD is a command
  ;; that adds to an existing archive and NEW-CMD is a command that makes a new
  ;; archive (overwriting an old one if it exists). ADD-CMD and NEW-CMD are:
  ;; 1. Nil (meaning we cannot do this for this type of archive) (one of
  ;;    ADD-CMD and NEW-CMD must be non-nil).
  ;; 2. A symbol that must be a function e.g. dired-do-archive-op.
  ;; 3. A format string with two arguments, the source files concatenated into
  ;;    a space separated string and the target archive.
  ;; 4. A list of strings, the command and its flags, to which the target and
  ;;    the source-files are concatenated."
  (setq dired-to-archive-copy-alist
        '(("\\.sh\\(ar\\|[0-9]\\)*$" nil "shar %s > %s")
          ("\\.jar$" ("jar" "uvf") ("jar" "cvf"))
          ("\\.tar$" ("tar" "-uf") ("tar" "-cf"))
          ("\\.tgz$\\|\\.tar\\.g?[zZ]$" ("tar" "-uf %s" "|" "gzip > %s") ("tar" "-czvf"))
          ("\\.ear$" ("zip" "-qr") ("zip" "-qr"))
                                        ;   ("\\.rar$" ("rar" "a")   ("rar" "a"))
          ("\\.war$" ("zip" "-qr") ("zip" "-qr"))
          ("\\.zip$" ("zip" "-qr") ("zip" "-qr"))
          ("\\.wmz$" ("zip" "-qr") ("zip" "-qr")) ;; for media player skins
          ("\\.arc$" ("arc" "a") nil)
          ("\\.zoo$" ("zoo" "aP") nil)
          ))

  ;; use pkzip with manipulating zip files (t) from within dired (use zip
  ;; and unzip otherwise)
  (setq archive-zip-use-pkzip nil)

  ;; add these file types to archive mode to allow viewing and changing
  ;; their contents
  (add-to-list 'auto-mode-alist '("\\.[ejrw]ar$\\'" . archive-mode))

  ;; modify the dired-extract switches to use the directory
  ;; ~/download/tryout as the default extract directory for zip files
  (defconst MY_TRYOUT_DIR "~/downloads/tryout"
    "Directory for extracting files")

  (setq dired-extract-alist
        `(
          ("\\.u\\(ue\\|aa\\)$" . dired-uud)
          ("\\.jar$" . "jar -xvf %s")
          ("\\.tar$" . ,(concat "tar -xf %s -C " MY_TRYOUT_DIR))
          ("\\.tgz$\\|\\.tar\\.g?[zZ]$" . ,(concat "tar -xzf %s -C " MY_TRYOUT_DIR))
          ("\\.arc$" . "arc x %s ")
          ("\\.bz2$" . ,(concat "bunzip2 -q %s"))
          ("\\.rar$" . ,(concat "unrar x %s " MY_TRYOUT_DIR "\\"))
          ("\\.zip$" . ,(concat "unzip -qq -Ux %s -d " MY_TRYOUT_DIR))
          ("\\.ear$" . ,(concat "unzip -qq -Ux %s -d " MY_TRYOUT_DIR))
          ("\\.war$" . ,(concat "unzip -qq -Ux %s -d " MY_TRYOUT_DIR))
          ("\\.zoo$" . "zoo x. %s ")
          ("\\.lzh$" . "lha x %s ")
          ("\\.7z$"  . "7z e %s ")
          ("\\.g?[zZ]$" . "gzip -d %s") ; There is only one file
          )))
#+END_SRC
** Calendar
*** Set up leader keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(map! :leader
      :desc "Calendar" "ac" #'=calendar)
#+END_SRC
*** Clean up after quitting
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add #'+calendar/quit
            :after
            (lambda (&rest _)
              (doom-kill-matching-buffers "^\\*cfw-calendar")))
#+END_SRC
*** Set up evil compatibility
:PROPERTIES:
:CREATED_TIME: [2020-01-19 Sun 11:55]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! calfw
  (evil-set-initial-state 'cfw:calendar-mode 'normal)
  (map! :map cfw:calendar-mode-map
        :m "j" #'cfw:navi-next-week-command
        :m "k" #'cfw:navi-previous-week-command
        :m "h" #'cfw:navi-previous-day-command
        :m "l" #'cfw:navi-next-day-command
        :m "^" #'cfw:navi-goto-week-begin-command
        :m "$" #'cfw:navi-goto-week-end-command
        :m "gg" #'cfw:navi-goto-first-date-command
        :m "G" #'cfw:navi-goto-last-date-command
        :m "C-j" #'cfw:navi-next-week-command
        :m "C-k" #'cfw:navi-previous-week-command
        :n "." #'cfw:navi-goto-today-command
        :m "gd" #'cfw:navi-goto-date
        :nm "TAB" #'cfw:navi-next-item-command
        :n "zm" #'cfw:change-view-month
        :n "zw" #'cfw:change-view-week
        :n "zt" #'cfw:change-view-two-weeks
        :n "zd" #'cfw:change-view-day
        :n "gr" #'cfw:refresh-calendar-buffer
        :n "f" #'cfw:show-details-command
        :n "RET" #'cfw:org-jump-map
        :n "q" #'+calendar/quit
        :map cfw:details-mode-map
        :n "gr" #'cfw:refresh-calendar-buffer
        :n "gd" #'cfw:org-goto-date
        :n "C" #'org-capture
        :n "q" #'cfw:org-clean-exit
        :n "zd" #'cfw:change-view-day
        :n "zw" #'cfw:change-view-week
        :n "zt" #'cfw:change-view-two-weeks
        :n "zm" #'cfw:change-view-month)
  (defun cfw:org-clean-exit-restore-focus-advice (&rest _)
    (when (get-buffer-window "*cfw-calendar*")
      (select-window (get-buffer-window "*cfw-calendar*"))))
  (advice-add #'cfw:org-clean-exit :after #'cfw:org-clean-exit-restore-focus-advice))
#+END_SRC
*** Set up my own calendar open function
:PROPERTIES:
:CREATED_TIME: [2020-01-22 Wed 13:22]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :app calendar)
  (defun my-open-calendar ()
    (interactive)
    (require 'calfw-cal)
    ;; (require 'calfw-ical)
    (require 'calfw-org)
    ;; (require 'calfw-howm)
    (cfw:open-calendar-buffer
     ;; :custom-map cfw:my-cal-map
     :contents-sources
     (list
      (cfw:org-create-source "Green")   ; orgmode source
      )))

  (setq +calendar-open-function #'my-open-calendar))
#+END_SRC

** Org
*** COMMENT Sync calendar
**** Configure variables & timers
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (after! ox-icalendar
    (setq org-icalendar-alarm-time 40
          org-icalendar-include-todo t
          org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo event-if-todo)
          org-icalendar-store-UID t))

  (after! org-caldav
    (load (expand-file-name "caldav" doom-private-dir))
    (when (boundp 'org-caldav-sync-todo)
      (setq org-caldav-sync-todo t)))

  (defvar org-caldav-sync-timer nil
    "Timer that `org-caldav-push-timer' used to reschedule itself, or nil.")

  (defun org-caldav-sync-with-delay (secs)
    (when org-caldav-sync-timer
      (cancel-timer org-caldav-sync-timer))
    (setq org-caldav-sync-timer
          (run-with-idle-timer
           (* 1 secs) nil 'org-caldav-sync)))

  (add-hook! 'after-save-hook
    (require 'ox-icalendar)
    (require 'org-caldav)
    (when (and (eq major-mode 'org-mode)
               (member (buffer-file-name)
                       org-caldav-files))
      (org-caldav-sync-with-delay 300)))

  ;; (add-hook 'kill-emacs-hook #'org-caldav-sync)
  )
#+END_SRC
**** Do not show popup if there are no new items
#+BEGIN_SRC emacs-lisp :tangle yes
(defun org-caldav-do-not-display-when-boring-advice (oldfun &rest args)
  (when org-caldav-sync-result
    (apply oldfun args)))

(advice-add #'org-caldav-display-sync-results :around #'org-caldav-do-not-display-when-boring-advice)
#+END_SRC
*** Automatically generate tables of contents
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 19:58]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! org-make-toc
  :hook (org-mode . org-make-toc-mode)
  :config
  (defun akirak/org-insert-toc-for-top-level ()
    (interactive)
    (unless (derived-mode-p 'org-mode)
      (user-error "Not in org-mode"))
    (org-with-wide-buffer
     (or (re-search-backward (rx bol "* ") nil t)
         (re-search-forward (rx bol "* ") nil t))
     (org-narrow-to-subtree)
     (when (org-find-property "TOC")
       (user-error "Already has a TOC"))
     (let ((heading (concat (make-string (org-get-valid-level 2) ?\*)
                            " ")))
       (if (re-search-forward (concat "^" (regexp-quote heading))
                              nil t)
           (beginning-of-line 1)
         (org-end-of-subtree)
         (unless (= 0 (car (posn-col-row (posn-at-point))))
           (insert "\n")))
       (insert heading "Table of contents\n")
       (beginning-of-line 0)
       (org-set-property "TOC" "siblings")))
    (add-file-local-variable 'before-save-hook 'org-make-toc)
    (save-buffer)
    (revert-buffer)))
#+END_SRC
*** Disable Eldoc in Org mode
:PROPERTIES:
:CREATED_TIME: [2020-01-27 Mon 12:00]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook! 'org-mode-hook
  (eldoc-mode -1))
#+END_SRC
*** Org journal
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 11:00]
:END:
**** For some reason Emacs Doom's code for auto-mode-alist is not running
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-journal
  (add-to-list 'auto-mode-alist (cons org-journal-file-pattern 'org-journal-mode)))
#+END_SRC
**** Please open journal entries in current window
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 13:05]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-journal
  (setq org-journal-find-file (lambda (&rest args)
                                (when (featurep! :ui workspaces)
                                  (+workspace-switch "Journal" t))
                                (apply #'find-file args))))
#+END_SRC

#+RESULTS:
: find-file

**** Calendar keybindings
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 12:08]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar org-journal-calendar-pre-window-conf nil)
(map! :leader
      :desc "Calendar" "njc" (lambda! (require 'org-journal)
                                      (setq org-journal-calendar-pre-window-conf (current-window-configuration))
                                      (calendar)))
(add-hook! 'doom-escape-hook
  (when (and (featurep 'org-journal)
             org-journal-calendar-pre-window-conf
             (get-buffer-window "*Calendar*"))
    (set-window-configuration org-journal-calendar-pre-window-conf)
    (setq org-journal-calendar-pre-window-conf nil)))

(after! org-journal
  (map! :map calendar-mode-map
        :n "o" #'org-journal-display-entry
        :n "w" #'org-journal-previous-entry
        :n "e" #'org-journal-next-entry
        :n "O" #'org-journal-new-date-entry
        :n "RET" (lambda! (let* ((_arg current-prefix-arg)
                                 (event last-nonmenu-event)
                                 (time (org-journal-calendar-date->time
                                        (calendar-cursor-to-date t event))))
                            (set-window-configuration org-journal-calendar-pre-window-conf)
                            (setq org-journal-calendar-pre-window-conf nil)
                            (org-journal-read-or-display-entry time nil)))
        :n "q" (lambda! (call-interactively #'calendar-exit)
                        (when org-journal-calendar-pre-window-conf
                          (set-window-configuration org-journal-calendar-pre-window-conf)
                          (setq org-journal-calendar-pre-window-conf nil))))
  (map! :map calendar-mode-map
        :localleader
        "w" #'org-journal-search-calendar-week
        "m" #'org-journal-search-calendar-month
        "y" #'org-journal-search-calendar-year))
#+END_SRC
**** Do not open buffer in view mode
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 12:26]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-journal
  (el-patch-defun org-journal-read-or-display-entry (time &optional noselect)
    "Read an entry for the TIME and either select the new window when NOSELECT
is nil or avoid switching when NOSELECT is non-nil."
    (let* ((org-journal-file (org-journal-get-entry-path time))
           (buf-exists (get-file-buffer org-journal-file))
           buf point)
      (if (and (when (file-exists-p org-journal-file)
                 (setq buf (find-file-noselect org-journal-file)))
               ;; If daily continoue with body of if condition
               (or (org-journal-daily-p)
                   ;; Search for journal entry
                   (with-current-buffer buf
                     (save-mark-and-excursion
                       (goto-char (point-min))
                       (setq point (re-search-forward
                                    (format-time-string " *:CREATED: *%Y%m%d" time) nil t))))))
          (progn
            ;; Use `find-file-noselect' instead of `view-file' as it does not respect `auto-mode-alist'
            (with-current-buffer buf
              ;; Open file in view-mode if not opened already.
              (el-patch-swap
                (unless buf-exists
                  (view-mode)
                  (setq view-exit-action 'kill-buffer))
                nil)
              (set (make-local-variable 'org-hide-emphasis-markers) t)
              (unless (org-journal-daily-p)
                (goto-char point))
              (org-journal-finalize-view)
              (setq point (point)))
            (el-patch-swap (if noselect
                               (display-buffer buf t)
                             (funcall org-journal-find-file org-journal-file))
                           (if noselect
                               (progn (mapc #'delete-window (cdr (doom-visible-windows)))
                                      (set-window-buffer (car (doom-visible-windows)) buf))
                             (funcall org-journal-find-file org-journal-file)))
            (set-window-point (get-buffer-window (get-file-buffer org-journal-file)) point)
            buf)
        (message "No journal entry for this date.")))))
#+END_SRC

#+RESULTS:
: org-journal-read-or-display-entry

**** Set popup rules
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 11:07]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-journal
  (set-popup-rule! "^\\*Org-journal search\\*$" :side 'bottom :size 0.3)
  
  (el-patch-defun org-journal-search-by-string (str &optional period-start period-end)
    "Search for a string within a given time interval.

If STR is empty, search for all entries using `org-journal-time-prefix'."
    (when (time-less-p period-end period-start)
      (error "Period end cannot be before the start"))
    (let* ((search-str (if (string= "" str) org-journal-time-prefix str))
           (files (org-journal-search-build-file-list period-start period-end))
           (results (org-journal-search-do-search search-str files))
           (buf (get-buffer-create org-journal-search-buffer))
           (inhibit-read-only t))
      (unless (get-buffer-window buf 0)
        (el-patch-swap (switch-to-buffer buf)
                       (pop-to-buffer buf)))
      (with-current-buffer buf
        (org-journal-search-mode)
        (erase-buffer)
        (org-journal-search-print-results str results period-start period-end)
        (goto-char (point-min))
        (forward-button 1)
        (button-activate (button-at (point))))))

  (map! :map org-journal-search-mode-map
        :n "q" #'kill-this-buffer
        :n "j" #'org-journal-search-next
        :n "k" #'org-journal-search-prev))
#+END_SRC
**** Set up a pleasant writing environment in Org journal mode
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 15:24]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook! 'org-journal-mode-hook
  (mixed-pitch-mode +1)
  (text-scale-set 2))
#+END_SRC
*** Add more reminders to Org
**** Enable reminders for currently clocked items and items with deadlines today
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (use-package! secretaria
    :defer-incrementally t
    :config
    (secretaria-unknown-time-always-remind-me)))
#+END_SRC
**** Enable reminders for overdue deadlines
#+BEGIN_SRC emacs-lisp :tangle yes
(after! secretaria
  (defvar secretaria-deadline-expiry 30
    "Amount of days necessary to auto-silence an overdue deadline.")

  (defun secretaria-get-overdue-appt ()
    (let* ((files (org-agenda-files))
           (appts)
           (entries (progn (setf org-agenda-buffer
                                 (when (buffer-live-p org-agenda-buffer)
                                   org-agenda-buffer))
                           (-non-nil
                            (-flatten (cl-loop for i from 1 to secretaria-deadline-expiry
                                               collect (cl-loop for file in (org-agenda-files)
                                                                collect (when-let ((entry (org-agenda-get-day-entries file (calendar-current-date (- i)) :scheduled :deadline)))
                                                                          (vector (car entry)
                                                                                  i))))))))
           (regexp (secretaria--leaders-prepare t))
           (org-agenda-skip-function '(secretaria--skip-entry-if-done))
           (org-clock-current-task (or org-clock-current-task "")))
      (dolist (entry entries)
        (when (and (string-match-p regexp (get-text-property 0 'extra (aref entry 0)))
                   (string-empty-p (get-text-property 0 'time (aref entry 0)))
                   (not (string-equal org-clock-current-task (substring-no-properties (get-text-property 0 'txt (aref entry 0))))))
          (push (vector (substring-no-properties (get-text-property 0 'txt (aref entry 0)))
                        (aref entry 1)) appts)))
      appts))

  (defun secretaria-alert-overdue-unknown-time-appt ()
    (let ((appts (secretaria-get-overdue-appt)))
      (dolist (entry appts)
        (alert (concat "(Task overdue by "
                       (number-to-string (aref entry 1))
                       " days)"
                       ;; ", time unspecified"
                       )
               :title (or (aref entry 0) "(no title)")
               :severity 'high
               :mode 'org-mode))))

  (defvar secretaria-overdue-unknown-time-reminder-timer nil)
  (setf secretaria-overdue-unknown-time-reminder-timer
        (run-at-time (format "%s min" (or secretaria-unknown-time-remind-time 30))
                     (* (or secretaria-unknown-time-remind-time 30) 60) 'secretaria-alert-overdue-unknown-time-appt)))
#+END_SRC
*** Setup appointment reminders
#+BEGIN_SRC emacs-lisp :tangle yes
(after! secretaria
  (defun my-org-agenda-to-appt ()
    (interactive)
    (setq appt-time-msg-list nil)
    (let ((org-deadline-warning-days 0))    ;; will be automatic in org 5.23
      (org-agenda-to-appt)))

  (defun aj/appt-notify (until time msg)
    "Use `alert' to for appointment notifications."
    (if (listp msg)
        (dolist (i (number-sequence 0 (1- (length until))))
          (alert (nth i msg) :title "Appointment Reminder" :category 'calendar))
      (alert msg :title "Appointment Reminder" :category 'calendar)))

  ;; Advice the agenda refresh to update appts.
  (defadvice org-agenda-redo (after update-appts activate)
    "Update `appt' lists from the agenda."
    (message "Updating appointments...")
    (aj/org-agenda-to-appt))

  (my-org-agenda-to-appt)
  (appt-activate +1)
  (setq appt-message-warning-time 20
        appt-display-interval 3
        appt-display-mode-line nil
        appt-disp-window-function #'aj/appt-notify
        appt-delete-window-function #'ignore))
#+END_SRC
*** Org agenda configuration
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:23]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-agenda
  (setq org-agenda-sticky t
        org-agenda-start-with-clockreport-mode t))
#+END_SRC
*** Capture templates
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-capture
  (add-to-list 'org-capture-templates
               `("a" "Appointment" entry
                 ,(list 'file
                        (concat org-directory "appointments.org"))
                 "* %?\nSCHEDULED: %^T\n%a\n"))
  (setq org-capture-templates
        (--remove (equal (car it) "n")
                  org-capture-templates))
  ;; (require 'doct)
  ;; (add-to-list 'org-capture-templates
  ;;              (doct '(("Note"
  ;;                       :keys "n"
  ;;                       :file (lambda () (let ((file (concat default-directory "notes.org")))
  ;;                                     ;;create if doesn't exist
  ;;                                     (set-buffer (find-file-noselect file t t))
  ;;                                     (write-file file) file))
  ;;                       :template (lambda () (if (y-or-n-p "link?")
  ;;                                           "* %doct:todo-state %A"
  ;;                                         "* %doct:todo-state %?"))
  ;;                       :todo-state "TODO"
  ;;                       :children (("bug" :keys "b"
  ;;                                   :headline "Bugs :bug:")
  ;;                                  ("enhancement" :keys "e"
  ;;                                   :headline "Ehnancements :enhancement:"
  ;;                                   :todo-state "IDEA")
  ;;                                  ("feature" :keys "f"
  ;;                                   :headline "Features :feature:"
  ;;                                   :todo-state "IDEA")
  ;;                                  ("optimization" :keys "o"
  ;;                                   :headline "Optimizations :optimization:")
  ;;                                  ("security" :keys "s"
  ;;                                   :headline "Security :security:"))))))
  )
#+END_SRC
*** Clocking configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-clock
  (setq org-clock-history-length 23
        org-clock-out-remove-zero-time-clocks t)
  (org-clock-persistence-insinuate))
#+END_SRC
*** Set up encryption
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (add-to-list 'org-modules 'org-crypt)
  (add-to-list 'org-tags-exclude-from-inheritance "crypt")
  (after! org-crypt
    (setq org-crypt-key user-mail-address)
    (org-crypt-use-before-save-magic)
    (setq org-crypt-disable-auto-save t)))
#+END_SRC
*** Record completion times for tasks
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (setq org-log-done t)
  (setq org-log-done-with-time t))
#+END_SRC
*** View current Org file as a tree
:PROPERTIES:
:CREATED_TIME: [2020-01-27 Mon 10:22]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! org-graph-view
  :commands org-graph-view
  :config
  (set-popup-rule! "^\\*org-graph-view\\*$" :size 0.4 :side 'bottom :quit t)
  (map! :map org-graph-view-map
        :nie "q" #'bury-buffer))
#+END_SRC
*** Activate speed commands
:PROPERTIES:
:CREATED_TIME: [2020-01-27 Mon 10:40]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-keys
  (setq org-use-speed-commands t))
#+END_SRC
*** Org source blocks
**** Clean up whitespace in source code blocks
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar +org-exit-src-code-hook nil
  "Hook run just before exiting a org source block buffer.")

(defun +org|run-exit-src-code-hooks (&rest _)
  "Runs all hooks in `+org-exit-src-code-hook`."
  (run-hooks '+org-exit-src-code-hook))

(advice-add #'org-edit-src-exit :before #'+org|run-exit-src-code-hooks)

(add-hook '+org-exit-src-code-hook #'ws-butler-trim-eob-lines)
#+END_SRC

#+RESULTS:
| (lambda nil (message hello)) | ws-butler-trim-eob-lines | whitespace-cleanup |
**** Auto-complete org block shortcuts
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! company-org-block
  :when (featurep! :completion company)
  :functions (company-org-block)
  :init
  (after! org
    (set-company-backend! 'org-mode 'company-org-block)))
#+END_SRC
**** COMMENT bidirectional syncing for tangled blocks
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! org-tanglesync
  :hook ((org-mode . org-tanglesync-mode)
         ;; enable watch-mode globally:
         ((prog-mode text-mode) . org-tanglesync-watch-mode))
  :bind
  (( "C-c M-i" . org-tanglesync-process-buffer-interactive)
   ( "C-c M-a" . org-tanglesync-process-buffer-automatic))
  :config
  (setq org-tanglesync-watch-files '("config.org")))
#+END_SRC
**** Org babel configuration
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:24]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (setq org-babel-load-languages '((emacs-lisp . t)
                                   (C . t)
                                   (R . t)
                                   (shell . t)
                                   (python . t)
                                   (lilypond . t)))
  (after! ob-lilypond
    (require 'lilypond-mode)
    (setq org-babel-lilypond-arrange-mode t)))
#+END_SRC
**** Custom Structure templates
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:49]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (add-to-list 'org-structure-template-alist
               '("l" . "src emacs-lisp"))
  (setq org-structure-template-alist (remove '("l" . "export latex") org-structure-template-alist)))
#+END_SRC
**** Use uppercase for blocks created by structure templates
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 10:37]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun org-insert-structure-template--pretty-advice (&rest _)
    (let (beg end)
      (save-excursion
        (re-search-backward "\n[\s\t]*#\\+begin_" nil t)
        (goto-char (match-beginning 0))
        (setq beg (point))
        (upcase-word 1)
        (when (looking-at "_[a-z]+")
          (upcase-word 1))
        (re-search-forward "\n[\s\t]*#\\+end_" nil t)
        (goto-char (match-beginning 0))
        (upcase-word 2)
        (end-of-line)
        (setq end (point)))
      (indent-region beg end))
    (when (looking-at "#\\+END_")
      (forward-char -1)
      (newline-and-indent)))

  (if (fboundp #'jit-disassemble)
      (defadvice org-insert-structure-template
          (after org-insert-structure-template--pretty-advice (&rest args) activate)
        (apply #'org-insert-structure-template--pretty-advice args))
    (advice-add #'org-insert-structure-template
                :after
                #'org-insert-structure-template--pretty-advice)))
#+END_SRC

#+RESULTS:
: org-insert-structure-template

**** Yank into source code blocks
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:28]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
;; Slightly different from the original for compatibility with my advice on
;; org-insert-structure-template
(after! org
  (defun akirak/org-yank-into-new-block ()
    (interactive)
    (let ((begin (point))
          done)
      (unwind-protect
          (progn
            (end-of-line)
            (yank)
            (push-mark begin)
            (setq mark-active t)
            (call-interactively #'org-insert-structure-template)
            (setq done t)
            (deactivate-mark)
            (let ((case-fold-search t))
              (re-search-forward (rx bol "#+END_")))
            (forward-line 1))
        (unless done
          (deactivate-mark)
          (delete-region begin (point))))))

  (map! :map org-mode-map
        "C-c C-'" #'akirak/org-yank-into-new-block))
#+END_SRC

*** Split org blocks with meta return
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 23:47]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun modi/org-in-any-block-p ()
    "Return non-nil if the point is in any Org block.
The Org block can be *any*: src, example, verse, etc., even any
Org Special block.
This function is heavily adapted from `org-between-regexps-p'."
    (save-match-data
      (let ((pos (point))
            (case-fold-search t)
            (block-begin-re "^[[:blank:]]*#\\+begin_\\(?1:.+?\\)\\(?: .*\\)*$")
            (limit-up (save-excursion (outline-previous-heading)))
            (limit-down (save-excursion (outline-next-heading)))
            beg end)
        (save-excursion
          ;; Point is on a block when on BLOCK-BEGIN-RE or if
          ;; BLOCK-BEGIN-RE can be found before it...
          (and (or (org-in-regexp block-begin-re)
                   (re-search-backward block-begin-re limit-up :noerror))
               (setq beg (match-beginning 0))
               ;; ... and BLOCK-END-RE after it...
               (let ((block-end-re (concat "^[[:blank:]]*#\\+end_"
                                           (match-string-no-properties 1)
                                           "\\( .*\\)*$")))
                 (goto-char (match-end 0))
                 (re-search-forward block-end-re limit-down :noerror))
               (> (setq end (match-end 0)) pos)
               ;; ... without another BLOCK-BEGIN-RE in-between.
               (goto-char (match-beginning 0))
               (not (re-search-backward block-begin-re (1+ beg) :noerror))
               ;; Return value.
               (cons beg end))))))

  (defun modi/org-split-block ()
    "Sensibly split the current Org block at point."
    (interactive)
    (if (modi/org-in-any-block-p)
        (save-match-data
          (save-restriction
            (widen)
            (let ((case-fold-search t)
                  (at-bol (bolp))
                  block-start
                  block-end)
              (save-excursion
                (re-search-backward "^\\(?1:[[:blank:]]*#\\+begin_.+?\\)\\(?: .*\\)*$" nil nil 1)
                (setq block-start (match-string-no-properties 0))
                (setq block-end (replace-regexp-in-string
                                 "begin_" "end_" ;Replaces "begin_" with "end_", "BEGIN_" with "END_"
                                 (match-string-no-properties 1))))
              ;; Go to the end of current line, if not at the BOL
              (unless at-bol
                (end-of-line 1))
              (insert (concat (if at-bol "" "\n")
                              block-end
                              "\n\n"
                              block-start
                              (if at-bol "\n" "")))
              ;; Go to the line before the inserted "#+begin_ .." line
              (beginning-of-line (if at-bol -1 0)))))
      (message "Point is not in an Org block")))

  (defun modi/org-meta-return (&optional arg)
    "Insert a new heading or wrap a region in a table.
Calls `org-insert-heading', `org-insert-item',
`org-table-wrap-region', or `modi/org-split-block' depending on
context.  When called with an argument, unconditionally call
`org-insert-heading'."
    (interactive "P")
    (org-check-before-invisible-edit 'insert)
    (or (run-hook-with-args-until-success 'org-metareturn-hook)
        (call-interactively (cond (arg #'org-insert-heading)
                                  ((org-at-table-p) #'org-table-wrap-region)
                                  ((org-in-item-p) #'org-insert-item)
                                  ((modi/org-in-any-block-p) #'modi/org-split-block)
                                  (t #'org-insert-heading)))))

  (advice-add 'org-meta-return :override #'modi/org-meta-return)
  )
#+END_SRC
*** Org id config
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:56]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-id
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+END_SRC
*** General org variables
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 22:20]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (setq org-blank-before-new-entry '((heading . nil)
                                     (plain-list-item . auto))
        org-pretty-entities t
        ;; Based on https://lepisma.xyz/2017/10/28/ricing-org-mode/
        ;; org-ellipsis " ‚åÑ "
        )

  ;; https://yiufung.net/post/org-mode-hidden-gems-pt1/
  (setq org-cycle-separator-lines 0
        org-catch-invisible-edits 'show-and-error))
#+END_SRC
*** COMMENT See org headline level in bullets
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org-bullets
  (setq org-bullets-bullet-list '("‚Ö†" "‚Ö°" "‚Ö¢" "‚Ö£" "‚Ö§" "‚Ö•")))
#+END_SRC
*** Disable Rainbow Delimiters in Org mode
:PROPERTIES:
:CREATED_TIME: [2020-01-28 Tue 10:32]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook! 'org-mode-hook
           (rainbow-delimiters-mode -1))
#+END_SRC
*** Save org fold states
:PROPERTIES:
:CREATED_TIME: [2020-01-21 Tue 16:48]
:END:
This code for persistent Org foldstates was copied directly from [[https://github.com/dandavison/org-fold][here]].
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun org-fold-get-fold-info-file-name ()
    (concat (buffer-file-name) ".fold"))

  (defun org-fold-save ()
    (save-excursion
      (goto-char (point-min))
      (let (foldstates)
        (unless (looking-at outline-regexp)
          (outline-next-visible-heading 1))
        (while (not (eobp))
          (push (if (some (lambda (o) (overlay-get o 'invisible))
                          (overlays-at (line-end-position)))
                    t)
                foldstates)
          (outline-next-visible-heading 1))
        (with-temp-file (org-fold-get-fold-info-file-name)
	        (prin1 (nreverse foldstates) (current-buffer))))))

  (defun org-fold-restore ()
    (save-excursion
      (goto-char (point-min))
      (let* ((foldfile (org-fold-get-fold-info-file-name))
	           (foldstates
	            (if (file-readable-p foldfile)
		              (with-temp-buffer
		                (insert-file-contents foldfile)
 		                (read (current-buffer))))))
        (when foldstates
	        (show-all)
          (goto-char (point-min))
          (unless (looking-at outline-regexp)
            (outline-next-visible-heading 1))
          (while (and foldstates (not (eobp)))
            (if (pop foldstates)
	              (hide-subtree))
            (outline-next-visible-heading 1))
          (message "Restored saved folding state")))))

  (add-hook 'org-mode-hook 'org-fold-activate 'append)

  (defun org-fold-activate ()
    (org-fold-restore)
    (add-hook 'kill-buffer-hook 'org-fold-kill-buffer nil t))

  (defun org-fold-kill-buffer ()
    ;; don't save folding info for unsaved buffers
    ;; (unless (buffer-modified-p)
    ;;   (org-fold-save))
    (org-fold-save)
    )
  )
#+END_SRC

*** Tree view of headers in sidebar
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (use-package! org-sidebar
    :bind (:map org-mode-map
            ("<f6>" . org-sidebar-toggle)
            ("<f7>" . org-sidebar-tree-toggle))
    :custom
    (org-sidebar-side 'left)
    (org-sidebar-tree-side 'left)))
#+END_SRC
*** Additional link types
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (use-package! orly
    :defer-incrementally t))
#+END_SRC
*** Use RET to create new list items
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! org-autolist
  :hook (org-mode . org-autolist-mode))
#+END_SRC
*** TODO org entry links
*** Add tags for completion in Org mode
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun org-add-completion-at-point ()
    (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point
              nil t))
  (add-hook 'org-mode-hook #'org-add-completion-at-point))
#+END_SRC
*** Add a creation timestamp to headings
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun akirak/org-set-created-timestamp (&rest args)
    "Add a creation timestamp to the current Org entry.
If the current command is run with a prefix argument, prevent
from running."
    (unless current-prefix-arg
      (org-set-property "CREATED_TIME"
                        (org-timestamp-format
                         (org-timestamp-from-time (current-time) t t)
                         (org-time-stamp-format t t)))))

  (advice-add #'org-insert-heading
              :after #'akirak/org-set-created-timestamp)
  (add-hook 'org-capture-mode-hook #'akirak/org-set-created-timestamp))
#+END_SRC
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 21:20]
:END:
*** Turn on automatic capitalization for Org mode
:PROPERTIES:
:CREATED_TIME: [2020-01-30 Thu 09:25]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook! 'org-mode-hook
           (turn-on-auto-capitalize-mode))
#+END_SRC
*** Bookmark headings
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 22:25]
:END:
#+BEGIN_EXPORT emacs-lisp :tangle yes
(use-package! org-bookmark-heading
  :after org
  :custom
  (org-bookmark-heading-filename-fn
   (defun akirak/org-bookmark-heading-filename (path)
     (let* ((path (expand-file-name path))
            (project (project-current))
            (dir (abbreviate-file-name (file-name-directory path)))
            (filename (file-name-nondirectory path))
            (root (car-safe (project-roots project))))
       (if root
           (f-relative path (f-parent root))
         path))))
  (org-bookmark-heading-name-fn
   (defun akirak/org-bookmark-heading (path heading)
     (let ((ancestors (org-get-outline-path)))
       (format "\"%s\" in %s%s"
               (substring-no-properties
                (org-link-display-format heading))
               (akirak/org-bookmark-heading-filename path)
               (if ancestors
                   (substring-no-properties
                    (concat ":" (org-format-outline-path
                                 (mapcar #'org-link-display-format ancestors)
                                 nil nil "/")))
                 ""))))))
#+END_EXPORT
*** Take notes for pdfs
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 12:26]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (use-package! org-noter
    :commands org-noter
    :config
    (setq org-noter-property-doc-file "INTERLEAVE_PDF"
          org-noter-property-note-location "INTERLEAVE_PAGE_NOTE")
    (setq org-noter-notes-window-location 'horizontal-split
          org-noter-always-create-frame nil
          org-noter-kill-frame-at-session-end nil
          org-noter-auto-save-last-location t))
  ;; (setq org-noter-default-notes-file-names
  ;;       '("elements.org" "Conceptual.org" "comprehension.org"))
  )
#+END_SRC
*** COMMENT Display the current Org heading in header line when off-screen.
:PROPERTIES:
:CREATED_TIME: [2020-01-23 Thu 09:30]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! org-sticky-header
  :hook (org-mode . org-sticky-header-mode))
#+END_SRC
*** Pollen Lozenge syntax for Org
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 15:55]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (use-package! lozenge
    :defer-incrementally t
    :config
    (lozenge-org-export-enable)
    (global-set-key (kbl-kbd "d" 'control 'meta nil 'super) #'lozenge-insert-lozenge)))
#+END_SRC

#+RESULTS:
: t
*** LaTeX
:PROPERTIES:
:CREATED_TIME: [2020-01-20 Mon 17:39]
:END:
**** COMMENT Vertically align LaTeX previews (doesn't work that well)
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 15:35]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add 'org--format-latex-make-overlay
            :after (lambda (beg end &rest args)
                     (let* ((ov (car (overlays-in beg end)))
                            (img (cdr (overlay-get ov 'display)))
                            (new-img (plist-put img :ascent 100)))
                       (overlay-put ov 'display (cons 'image new-img)))))
#+END_SRC

#+RESULTS:
**** Allow Company Auctex in Org mode
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 23:27]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defun my-company-auctex-prefix (regexp)
    "Returns the prefix for matching given REGEXP."
    (and (or (derived-mode-p 'latex-mode)
             (and (derived-mode-p 'org-mode)
                  (lattie--math-p)))
         (when (looking-back regexp)
           (match-string-no-properties 1))))

  (advice-add #'company-auctex-prefix :override #'my-company-auctex-prefix)

  (set-company-backend! 'org-mode 'company-auctex-symbols))
#+END_SRC
**** Add more packages to Org LaTeX
:PROPERTIES:
:CREATED_TIME: [2020-01-23 Thu 11:28]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (add-to-list 'org-latex-packages-alist
               '("" "amsmath"))
  (add-to-list 'org-latex-packages-alist
               '("" "amssymb"))
  (add-to-list 'org-latex-packages-alist
               '("" "mathrsfs"))
  ;; Has \coloneqq
  (add-to-list 'org-latex-packages-alist
               '("" "mathtools"))
  (add-to-list 'org-latex-packages-alist
               '("" "tikz"))
  (add-to-list 'org-latex-packages-alist
               '("" "tikz-cd")))
#+END_SRC
**** Do not prettify subscripts nor superscripts
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 18:09]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (setq org-pretty-entities-include-sub-superscripts nil))
#+END_SRC
**** Configure Org LaTeX export process
:PROPERTIES:
:CREATED_TIME: [2020-01-23 Thu 11:42]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (setq org-latex-pdf-process '("latexmk -pdflatex='lualatex -shell-escape -interaction nonstopmode' -pdf -f  %f")
        org-preview-latex-default-process 'dvisvgm))
#+END_SRC
**** LaTeX input shortcuts
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 15:22]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'org-cdlatex-mode)
#+END_SRC
**** Org DWIM
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 15:52]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(add-transient-hook! 'org-cdlatex-mode-hook
  (map! :map org-cdlatex-mode-map
        "]" #'lattie-close-bracket
        "[" #'lattie-open-bracket
        "(" #'lattie-open-paren
        "n" #'special-lattie-down
        "-" #'special-lattie-punctuation
        "SPC" #'special-lattie-space
        "." #'special-lattie-space
        "," #'special-lattie-space
        "+" #'lattie-insert-dollar
        "e" #'special-lattie-up
        "m" #'special-lattie-backward
        "i" #'special-lattie-forward
        "t" #'special-lattie-flow
        "c" #'special-lattie-toggle-latex-fragment
        "$" #'special-lattie-dollar
        "{" #'special-lattie-open-brace
        "}" #'special-lattie-close-brace
        "f" #'special-lattie-compile
        "*" #'special-lattie-asterisk
        "`" #'special-lattie-grave
        "0" #'special-lattie-digit-or-bol
        "1" #'special-lattie-digit
        ;; "^" #'special-lattie-back-to-heading
        "^" #'org-cdlatex-underscore-caret
        "2" #'special-lattie-digit
        "3" #'special-lattie-digit
        "4" #'special-lattie-digit
        "5" #'special-lattie-digit
        "6" #'special-lattie-digit
        "7" #'special-lattie-digit
        "8" #'special-lattie-digit
        "9" #'special-lattie-digit
        ;; "=" #'special-lattie-equals
        ;; "/" #'special-lattie-slash
        [return] #'special-lattie-newline-and-indent
        "DEL" #'lattie-delete-backward
        [remap backward-kill-word] #'backward-kill-word
        [remap org-self-insert-command] #'lattie-self-insert-command)

  (after! org
    (require 'org-element)
    (require 'texmathp)
    (require 'cdlatex)
    (require 'typo)

    (when (not (featurep 'lispy))
      (defmacro lispy-dotimes (n &rest bodyform)
        "Execute N times the BODYFORM unless an error is signaled.
Return nil if couldn't execute BODYFORM at least once.
Otherwise return the amount of times executed."
        (declare (indent 1)
                 (debug (form body)))
        `(let ((i 0))
           (catch 'result
             (condition-case e
                 (progn
                   (while (<= (cl-incf i) ,n)
                     ,@bodyform)
                   ,n)
               (error
                (when (eq (car e) 'buffer-read-only)
                  (message "Buffer is read-only: %s" (current-buffer)))
                (cl-decf i)
                (and (> i 0) i)))))))

    (defvar lattie-dollar-regexp "[^\\]\\$")
    (defvar lattie-dollar-regexp-for-looking-at "\\$")

    (defvar lattie-closing-math-regexp
      (concat lattie-dollar-regexp
              "\\|[^\\]\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-closing-math-regexp-for-looking-at
      (concat lattie-dollar-regexp-for-looking-at
              "\\|\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-opening-math-regexp
      (concat lattie-dollar-regexp
              "\\|[^\\]\\\\\\(\\\[\\|\(\\|begin\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-opening-math-regexp-for-looking-at
      (concat lattie-dollar-regexp-for-looking-at
              "\\|\\\\\\(\\\[\\|\(\\|begin\{[^\\s$\\s-]+\}\\)"))

    (defvar lattie-closing-math-regexp-with-whitespace
      (concat "\\s-*"
              lattie-dollar-regexp
              "\\|[^\\]\\\\\\(\\s-*\]\\|\\s-*\)\\|\\s-*end\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-closing-math-regexp-with-whitespace-for-looking-at
      (concat "\\s-*"
              lattie-dollar-regexp-for-looking-at
              "\\|[^\\]\\\\\\(\\s-*\]\\|\\s-*\)\\|\\s-*end\{[^\\s$\\s-]+\}\\)"))

    (defvar lattie-opening-math-regexp-with-whitespace
      (concat lattie-dollar-regexp
              "\\s-*\\|[^\\]\\\\\\(\\\[\\s-*\\|\(\\s-*\\|begin\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-opening-math-regexp-with-whitespace-for-looking-at
      (concat lattie-dollar-regexp-for-looking-at
              "\\s-*\\|\\\\\\(\\\[\\s-*\\|\(\\s-*\\|begin\{[^\\s$\\s-]+\}\\)"))

    (defvar lattie-closing-or-environment-math-regexp
      (concat lattie-dollar-regexp
              "\\|[^\\]\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-closing-or-environment-math-regexp-for-looking-at
      (concat lattie-dollar-regexp-for-looking-at
              "\\|\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))

    (defvar lattie-opening-or-environment-math-regexp
      (concat lattie-dollar-regexp
              "\\|[^\\]\\\\\\(\\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-opening-or-environment-math-regexp-for-looking-at
      (concat lattie-dollar-regexp-for-looking-at
              "\\|\\\\\\(\\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))

    (defvar lattie-closing-or-opening-math-regexp
      (concat lattie-dollar-regexp
              "\\|[^\\]\\\\\\(\]\\|\)\\|\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))
    (defvar lattie-closing-or-opening-math-regexp
      (concat lattie-dollar-regexp-for-looking-at
              "\\|\\\\\\(\]\\|\)\\|\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))

    (defvar lattie-closing-environment-regexp "[^\\]\\\\end\{\\([^\\s$\\s-]+\\)\}")
    (defvar lattie-closing-environment-regexp-for-looking-at "\\\\end\{\\([^\\s$\\s-]+\\)\}")
    (defvar lattie-opening-environment-regexp "[^\\]\\\\begin\{\\([^\\s$\\s-]+\\)\}")
    (defvar lattie-opening-environment-regexp-for-looking-at "\\\\begin\{\\([^\\s$\\s-]+\\)\}")
    (defvar lattie-open-or-close-environment-regexp "[^\\]\\\\end\{[^\\s$\\s-]+\}\\|[^\\]\\\\begin\{[^\\s$\\s-]+\}")
    (defvar lattie-open-or-close-environment-regexp-for-looking-at "\\\\end\{[^\\s$\\s-]+\}\\|\\\\begin\{[^\\s$\\s-]+\}")

    (defvar lattie-debug nil)
    (defvar lattie--left-matched? nil)

    (defun lattie--math-p (&optional pt)
      (let* ((pt-old (or pt (point)))
             (pt-new (if (and (eq (char-after pt-old) ?\n)
                              (not (eq (char-before (1- pt-old)) ?$)))
                         (1- pt-old)
                       pt-old))
             (face-at-pt (get-text-property (or pt-new (point)) 'face)))
        (or (and (listp face-at-pt)
                 (or (memq 'org-latex-and-related face-at-pt)
                     (memq 'font-latex-math-face face-at-pt)
                     (memq 'font-latex-sedate-face face-at-pt)
                     (memq 'font-function-function-name-face face-at-pt)
                     (memq 'tex-math face-at-pt)
                     (memq 'endless/unimportant-latex-face face-at-pt)
                     ;; (memq 'rainbow-delimiters-depth-1-face face-at-pt)
                     ;; (memq 'rainbow-delimiters-depth-2-face face-at-pt)
                     ;; (memq 'rainbow-delimiters-depth-3-face face-at-pt)
                     ;; (memq 'rainbow-delimiters-depth-4-face face-at-pt)
                     ))
            (eq face-at-pt 'tex-math))))

    (defun lattie--left-p ()
      (or (and (looking-at lattie-opening-math-regexp-for-looking-at)
               (or (not (eq (char-after) ?$))
                   (eq (char-before) ?\n)
                   (lattie--at-left-side-of-opening-expression?))
               (or (not (eq (char-after) ?$))
                   (eq (char-before) ?\n)
                   (not (looking-back lattie-closing-math-regexp (point-at-bol) nil))))
          (looking-at lattie-open-or-close-environment-regexp-for-looking-at)))

    (defun lattie--right-p ()
      (or (and (looking-back lattie-closing-math-regexp (point-at-bol) nil)
               (or (not (eq (char-before) ?$))
                   (eq (char-after) ?\n)
                   (lattie--at-right-side-of-closing-expression?))
               (or (not (eq (char-before) ?$))
                   (eq (char-after) ?\n)
                   (not (looking-at lattie-opening-math-regexp-for-looking-at))))
          (looking-back lattie-open-or-close-environment-regexp (point-min) nil)))

    (defmacro lattie-stay-special (&rest forms)
      `(let ((pt (point)))
         ,@forms
         (while (and (not (eq (point) pt))
                     (or (eq (char-before) ?\\)
                         ;; (looking-back "\\\\]" (- (point) 3))
                         (invisible-p (point))
                         (looking-back "\\\\\\\\\\\(\)\\|\]\\)" (- (point) 3))))
           ,@forms
           (setq pt (point)))
         (when (or (eq (point) ,(point))
                   (eq (char-before) ?\\)
                   ;; (looking-back "\\\\)" (- (point) 3))
                   ;; (looking-back "\\\\]" (- (point) 3))
                   (invisible-p (point))
                   (looking-back "\\\\\\\\\\\(\)\\|\]\\)" (- (point) 3)))
           (goto-char ,(point)))))

    (defun lattie--at-left-side-of-opening-expression? ()
      (save-excursion
        (not (lattie--math-p
              (progn (re-search-backward "[^\\s.]" nil t)
                     ;; (re-search-backward "[^\\sw]" nil t)
                     (while (eq (char-before) ?\\)
                       (forward-char -1))
                     (point))))))

    (defun lattie--at-right-side-of-closing-expression? ()
      (save-excursion
        (and (not (and (eq (char-after) ?$)
                       (eq (- (point-max) (point))
                           1)))
             (or (and (eq (char-before) ?$)
                      (eq (char-after) ?\n))
                 (not (lattie--math-p
                       (progn (unless (or (looking-at "[^\s.\$]+\\$")
                                          (and (eq (char-before) ?$)
                                               (eq (char-after) ?$)))
                                (re-search-forward "[^\\s.]" nil t))
                              (while (eq (char-before) ?\\)
                                (forward-char -1))
                              (point))))))))

    (defun lattie--special-p ()
      (or (lattie--left-p)
          (lattie--right-p)))

    (defun lattie--get-forward-limit ()
      (save-excursion
        (if (looking-back lattie-opening-environment-regexp (1- (point-at-bol)) nil)
            (goto-char (match-beginning 0))
          (forward-char -1))
        ;; (message "initial: %s %s" (match-string 0) (match-string 1))
        (let* ((limit (save-excursion (re-search-forward lattie-closing-math-regexp nil t)))
               (match (match-data))
               (op (re-search-forward lattie-opening-environment-regexp limit t))
               (new-limit? (and (match-string-no-properties 1)
                                ;; (message "%s" (match-string-no-properties 1))
                                (save-excursion
                                  (re-search-forward
                                   (concat "[^\\]\\\\end{\\("
                                           (regexp-quote (match-string-no-properties 1))
                                           "\\)}")
                                   nil
                                   t)))))
          (unless new-limit? (set-match-data match))
          ;; (message "limits: %s %s %s %s" limit new-limit? op (match-string-no-properties 1))
          (when (match-string-no-properties 1)
            (while (and (integerp op)
                        (integerp new-limit?)
                        (integerp limit)
                        (< op limit)
                        (< limit new-limit?))
              (setq limit new-limit?
                    match (match-data)
                    op (re-search-forward lattie-opening-environment-regexp limit t)
                    new-limit? (save-excursion
                                 (re-search-forward
                                  (concat "[^\\]\\\\end{\\("
                                          (regexp-quote (match-string-no-properties 1))
                                          "\\)}")
                                  nil
                                  t)))
              ;; (message "new limit: %s %s %s" limit new-limit? op)
              ))
          (set-match-data match)
          ;; (message "final limit: %s %s" limit (match-string 0))
          limit)))

    ;; (defun lattie--get-backward-limit ()
    ;;   (save-excursion
    ;;     (if (looking-at lattie-closing-environment-regexp-for-looking-at)
    ;;         (goto-char (match-end 0))
    ;;       (forward-char -1))
    ;;     ;; (message "initial: %s %s" (match-string 0) (match-string 1))
    ;;     (let* ((limit (save-excursion (re-search-backward lattie-opening-math-regexp nil t)))
    ;;            (match (match-data))
    ;;            (cl (re-search-backward lattie-closing-environment-regexp limit t))
    ;;            (new-limit? (and (match-string-no-properties 1)
    ;;                             ;; (message "%s" (match-string-no-properties 1))
    ;;                             (save-match-data
    ;;                               (re-search-backward
    ;;                                (concat "[^\\]\\\\begin{"
    ;;                                        (regexp-quote (match-string-no-properties 1))
    ;;                                        "}")
    ;;                                nil
    ;;                                t)))))
    ;;       ;; (message "limits: %s %s %s %s" limit new-limit? op (match-string-no-properties 1))
    ;;       (when (match-string-no-properties 1)
    ;;         (while (and (integerp cl)
    ;;                     (integerp new-limit?)
    ;;                     (integerp limit)
    ;;                     (> op limit)
    ;;                     (> limit new-limit?))
    ;;           (setq limit new-limit?
    ;;                 match (match-data)
    ;;                 op (re-search-backward lattie-closing-environment-regexp limit t)
    ;;                 new-limit? (save-excursion
    ;;                              (re-search-backward
    ;;                               (concat "[^\\]\\\\begin{"
    ;;                                       (regexp-quote (match-string-no-properties 1))
    ;;                                       "}")
    ;;                               nil
    ;;                               t)))
    ;;           ;; (message "new limit: %s %s %s" limit new-limit? op)
    ;;           ))
    ;;       (set-match-data match)
    ;;       limit)))

    (defun lattie-forward (arg)
      (interactive "p")
      (lispy-dotimes arg
        (lattie--trim-whitespace-right)
        (lattie--get-forward-limit)
        (forward-char -1)
        (if (eq (point)
                (progn (cond ((string-prefix-p "\\end{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                              (goto-char (match-end 0)))
                             ((re-search-forward lattie-closing-math-regexp nil t)
                              (when (not (lattie--right-p))
                                (re-search-forward lattie-closing-math-regexp nil t)))
                             ((eq (char-after) ?\})
                              (forward-char 1)))
                       (point)))
            (progn (lattie--trim-whitespace-right)
                   (forward-char 1))
          (lattie--trim-whitespace-right))))

    (defmacro lattie-dotimes (n &rest forms)
      `(dotimes (_i ,n)
         ,@forms))

    (defun lattie-backward (arg)
      (interactive "p")
      (lispy-dotimes arg
        (if (looking-back lattie-closing-environment-regexp (1- (point-at-bol)) nil)
            (re-search-backward (concat "\\\\begin\{"
                                        (regexp-quote (match-string-no-properties 1))
                                        "}")
                                nil
                                t)
          (lattie-stay-special (re-search-backward lattie-opening-math-regexp nil t)
                               (forward-char 1))
          (when (not (lattie--left-p))
            (lattie-stay-special
             (re-search-backward lattie-opening-math-regexp nil t)
             (forward-char 1))))
        ;; (lattie--trim-whitespace-left)
        ))

    (defun lattie--trim-whitespace-right ()
      (cond ((eq (char-before) ?$)
             (forward-char -1)
             (let* ((end (point))
                    (offset (skip-syntax-backward "\\s-"))
                    (s (buffer-substring-no-properties (+ end offset) end)))
               (unless (progn (delete-region (+ end offset) end)
                              (forward-char 1)
                              (prog1 (lattie--at-right-side-of-closing-expression?)
                                (forward-char -1)))
                 (insert s)))
             (forward-char 1))))

    ;; (defun lattie--trim-whitespace-left ()
    ;;   (cond ((eq (char-after) ?$)
    ;;          (forward-char 1)
    ;;          (let* ((beg (point))
    ;;                 (offset (skip-syntax-forward "\\s-"))
    ;;                 (s (buffer-substring-no-properties (+ beg offset) beg)))
    ;;            (unless (progn (delete-region beg (+ beg offset))
    ;;                           (lattie--at-left-side-of-opening-expression?))
    ;;              (insert s)))
    ;;          (forward-char -1))))

    (defun lattie--debug (&rest args)
      (when lattie-debug
        (apply #'message args)))

    (defun lattie-right (arg)
      "FIXME Maybe I should just remove this."
      (skip-syntax-backward "\\s-" (point-at-eol))
      (lispy-dotimes arg
        (unless (lattie--at-right-side-of-closing-expression?)
          (cond ((looking-at lattie-opening-environment-regexp-for-looking-at)
                 (goto-char (match-end 0)))
                (t (lattie-forward 1))))))

    (defun lattie-left (arg)
      "FIXME Maybe I should just remove this"
      (let ((pt (point)))
        (skip-syntax-backward "\\s-" (point-at-bol))
        (when (eq (point)
                  (progn (lispy-dotimes arg
                           (unless (and (lattie--at-left-side-of-opening-expression?)
                                        (not (looking-at lattie-open-or-close-environment-regexp-for-looking-at)))
                             (cond ((looking-at lattie-open-or-close-environment-regexp-for-looking-at)
                                    (goto-char (match-end 0))
                                    (lattie-backward 1))
                                   ((looking-back lattie-closing-environment-regexp (1- (point-at-bol)) t)
                                    (goto-char (1+ (match-beginning 0))))
                                   (t (lattie-backward 1)))))
                         (point)))
          (goto-char pt))))

    (defun lattie-up (arg)
      (let ((data nil)
            (pt (point)))
        (lispy-dotimes arg
          (lattie--special-p)
          (cond ((or (string-prefix-p "\\end\{" (match-string-no-properties 0))
                     (string-prefix-p "\\begin\{" (match-string-no-properties 0)))
                 (if (looking-at lattie-open-or-close-environment-regexp-for-looking-at)
                     (progn (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                            (forward-char 1)
                            (when (string-suffix-p "$" (match-string-no-properties 0))
                              (re-search-backward lattie-opening-or-environment-math-regexp nil t)
                              (forward-char 1)))
                   (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                   (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                   (when (string-suffix-p "$" (match-string-no-properties 0))
                     (re-search-forward lattie-closing-math-regexp nil t))
                   (goto-char (match-end 0))))
                ((eq (char-before) ?$)
                 (save-excursion (re-search-backward lattie-closing-math-regexp nil t))
                 (when (string-suffix-p "$" (match-string-no-properties 0))
                   (progn (goto-char (1+ (match-beginning 0)))
                          (setq data (match-data))
                          (re-search-backward lattie-closing-math-regexp nil t)
                          (re-search-backward lattie-closing-math-regexp nil t)))
                 (goto-char (match-end 0))
                 (when (and (eq (char-before) ?$)
                            (not (lattie--right-p)))
                   (set-match-data data)
                   (goto-char (match-end 0))))
                ((lattie--right-p)
                 (goto-char (1+ (match-beginning 0)))
                 (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                 (goto-char (match-end 0)))
                ((lattie--left-p)
                 (re-search-backward lattie-opening-or-environment-math-regexp nil t)
                 (unless (equal (match-string-no-properties 0) "\n")
                   (goto-char (1+ (match-beginning 0))))
                 (when (string-suffix-p "$" (match-string-no-properties 0))
                   (progn (goto-char (match-beginning 0))
                          (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                          (forward-char 1))))))
        (when (< pt (point))
          (goto-char pt))))

    (defun lattie-down (arg)
      (let ((data nil)
            (pt (point)))
        (lispy-dotimes arg
          (lattie--special-p)
          (cond ((or (string-match-p "\\\\end\{" (match-string-no-properties 0))
                     (string-match-p "\\\\begin\{" (match-string-no-properties 0)))
                 (if (looking-at lattie-open-or-close-environment-regexp-for-looking-at)
                     (progn (goto-char (match-end 0))
                            (re-search-forward lattie-closing-or-environment-math-regexp nil t)
                            (goto-char (1+ (match-beginning 0))))
                   (goto-char (match-end 0))
                   ;; I am currently at the right side of \\begin/end{...} statement
                   (re-search-forward lattie-open-or-close-environment-regexp nil t)
                   (when (string-suffix-p "$" (match-string-no-properties 0))
                     (progn (goto-char (match-end 0))
                            (setq data (match-data))
                            (re-search-forward lattie-closing-math-regexp nil t)))))
                ((eq (char-before) ?$)
                 (save-excursion (re-search-forward lattie-closing-or-opening-math-regexp nil t))
                 (setq data (match-data))
                 (when (string-suffix-p "$" (match-string-no-properties 0))
                   (progn (goto-char (match-end 0))
                          (setq data (match-data))
                          (re-search-forward lattie-closing-math-regexp nil t)))
                 (goto-char (match-end 0))
                 (when (and (eq (char-before) ?$)
                            (not (lattie--right-p)))
                   (set-match-data data)
                   (goto-char (match-end 0))))
                ((eq (char-after) ?$)
                 (forward-char 1)
                 (re-search-forward lattie-opening-or-environment-math-regexp nil t)
                 (when (string-match-p "\$$" (match-string-no-properties 0))
                   (progn (goto-char (match-end 0))
                          (re-search-forward lattie-opening-or-environment-math-regexp nil t)
                          (goto-char (1+ (match-beginning 0)))))
                 )
                ((lattie--right-p)
                 (goto-char (match-end 0))
                 (re-search-forward lattie-closing-or-environment-math-regexp nil t)
                 (when (string-suffix-p "$" (match-string-no-properties 0))
                   (progn (goto-char (match-end 0))
                          (setq data (match-data))
                          (re-search-forward lattie-opening-or-environment-math-regexp nil t))))
                ((lattie--left-p)
                 (goto-char (match-end 0))
                 (re-search-forward lattie-opening-or-environment-math-regexp nil t)
                 (goto-char (match-beginning 0)))))
        (when (<= (1- (point)) pt)
          (goto-char pt))))

    ;; (defun lattie-up (arg)
    ;;   (interactive "p")
    ;;   (cond ((lattie--left-p)
    ;;          (lattie-backward arg)
    ;;          (lattie-left 1))
    ;;         ((lattie--right-p)
    ;;          (lattie-backward (1+ arg))
    ;;          (lattie-right 1))))

    (defun lattie-self-insert-command (arg)
      (interactive "p")
      (when (looking-back lattie-closing-math-regexp (point-at-bol))
        (put-text-property (1- (point))
                           (point)
                           'font-lock-face
                           nil))
      (if (memq major-mode '(org-mode org-journal-mode))
          (org-self-insert-command arg)
        (self-insert-command arg)))

    (defun special-lattie-grave ()
      (interactive)
      (if (or (lattie--math-p)
              (looking-back ",[a-zA-Z0-9]*" (point-at-bol) nil))
          (cdlatex-math-symbol)
        (typo-cycle-left-single-quotation-mark 1)))

    (defun special-lattie-backward (arg)
      (interactive "p")
      (if (lattie--special-p)
          (lattie-backward arg)
        (lattie-self-insert-command arg)))

    (defun special-lattie-up (arg)
      (interactive "p")
      (cond ((lattie--special-p)
             (lattie-stay-special (lattie-up arg)))
            ;; ((and (eq major-mode 'org-mode)
            ;;       (org-at-heading-p))
            ;;  (org-next-visible-heading arg))
            ;; ((and (eq major-mode 'org-mode)
            ;;       (org-at-item-p))
            ;;  (lispy-dotimes arg (org-next-item)))
            (t (lattie-self-insert-command arg))))

    (defun special-lattie-down (arg)
      (interactive "p")
      (cond ((lattie--special-p)
             (lattie-stay-special (lattie-down arg)))
            ;; ((and (eq major-mode 'org-mode)
            ;;       (org-at-heading-p))
            ;;  (org-next-visible-heading arg))
            ;; ((and (eq major-mode 'org-mode)
            ;;       (org-at-item-p))
            ;;  (lispy-dotimes arg (org-next-item)))
            (t (lattie-self-insert-command arg))))

    (defun special-lattie-left (arg)
      (interactive "p")
      (cond ((lattie--special-p)
             (lattie-left arg))
            ;; ((and (eq major-mode 'org-mode)
            ;;       (org-at-heading-or-item-p))
            ;;  (org-up-element))
            (t (lattie-self-insert-command arg))))

    (defun special-lattie-right (arg)
      (interactive "p")
      (cond ((lattie--special-p)
             (lattie-right arg))
            ;; ((and (eq major-mode 'org-mode)
            ;;       (org-at-heading-or-item-p))
            ;;  (org-down-element))
            (t (lattie-self-insert-command arg))))

    (defun lattie-delete-backward (arg)
      (interactive "p")
      (cond (mark-active
             (kill-region (mark) (point)))
            ((and (eq (char-after) ?$)
                  (eq (char-before) ?$))
             (delete-char 1)
             (delete-char -1))
            ((and (looking-at "\\(\\\\\\{0,2\\}\\)\\(\)\\|\\]\\|\}\\)")
                  (looking-back (concat (regexp-quote (match-string-no-properties 1))
                                        (regexp-quote (cond ((equal (match-string-no-properties 2) ")")
                                                             (identity "("))
                                                            ((equal (match-string-no-properties 2) "]")
                                                             (identity "["))
                                                            ((equal (match-string-no-properties 2) "}")
                                                             (identity "{")))))
                                (point-at-bol)
                                nil))
             (delete-region (- (point) (- (match-end 0) (match-beginning 0)))
                            (+ (point) (- (match-end 0) (match-beginning 0)))))
            ((and (not (lattie--math-p))
                  (eq (char-before) (char-after))
                  (memq (char-before) '(?* ?/ ?=)))
             (delete-region (1- (point)) (1+ (point))))
            ((and (eq (char-before) (char-before (1- (point))))
                  (memq (char-before) '(?* ?/ ?=))
                  (not (lattie--math-p)))
             (if (and (memq major-mode '(org-mode org-journal-mode))
                      (looking-back "^\\*+" (point-at-bol) nil))
                 (org-delete-char -1)
               (delete-region (- (point) 2) (point))))
            ((looking-back "\\\\\\{0,2\\}\{\\\\\\{0,2\\}\}" (point-at-bol) nil)
             (delete-region (match-beginning 0) (match-end 0)))
            ((looking-back "\\\\\\{0,2\\}\\[\\\\\\{0,2\\}\\]" (point-at-bol) nil)
             (delete-region (match-beginning 0) (match-end 0)))
            ((looking-back "\\\\\\{0,2\\}\(\\\\\\{0,2\\}\)" (point-at-bol) nil)
             (delete-region (match-beginning 0) (match-end 0)))
            ((lattie--right-p)
             (cond ((and          ;(message "%s" (match-string-no-properties 0))
                     (string-prefix-p "\\begin{" (substring-no-properties (match-string-no-properties 0) 1 nil))))
                   ((and          ;(message "%s" (match-string-no-properties 0))
                     (string-prefix-p "\\end{" (substring-no-properties (match-string-no-properties 0) 1 nil)))
                    (kill-region (save-match-data
                                   (re-search-backward
                                    (regexp-quote (concat "\\begin{"
                                                          (substring-no-properties (match-string-no-properties 0)
                                                                                   6
                                                                                   (- (match-end 0) (match-beginning 0) 1))
                                                          "}"))
                                    nil))
                                 (match-end 0)))
                   (t (apply #'kill-region
                             (nreverse (list (point)
                                             (progn (lattie-left arg) (point))))))))
            ((and (looking-back "\\\\begin\{\\([^\s$\s-]+\\)\}" (point-at-bol) nil)
                  (match-string-no-properties 1)
                  (equal (regexp-quote (match-string-no-properties 1))
                         (and (looking-at "\n?\\\\end\{\\([^\s$\s-]+\\)\}")
                              (match-string-no-properties 1))))
             (delete-region (match-beginning 0)
                            (match-end 0))
             (delete-region (point)
                            (re-search-backward "\\\\begin\{\\([^\s$\s-]+\\)\}")))
            ((memq major-mode '(org-mode org-journal-mode))
             (if-let ((context (and (memq major-mode '(org-mode org-journal-mode))
                                    (org-element-context))))
                 (cond ((and (eq (car context) 'item)
                             (org-element-property :checkbox context)
                             (< (- (point) (org-element-property :begin context)) 7))
                        (delete-region (point) (+ (org-element-property :begin context)
                                                  (length (org-element-property :bullet context)))))
                       ((and (eq (car context) 'item)
                             (org-element-property :bullet context)
                             (= (point) (+ (org-element-property :begin context)
                                           (length (org-element-property :bullet context)))))
                        (delete-region (point) (org-element-property :begin context)))
                       ((and (eq (car context) 'headline)
                             (org-element-property :todo-keyword context)
                             (< (- (point)
                                   (length (org-element-property :todo-keyword context))
                                   (org-element-property :level context)
                                   (org-element-property :begin context))
                                3))
                        (delete-region (point)
                                       (+ (org-element-property :begin context)
                                          (org-element-property :level context)
                                          1)))
                       (t (let ((pt (point)))
                            (if (not (eq 0 (skip-syntax-backward "\\s-")))
                                (delete-region (point) pt)
                              (unless (eq arg 0) (delete-char (1+ (- arg)))
                                      (org-delete-char -1))))))
               (let ((pt (point)))
                 (if (not (eq 0 (skip-syntax-backward "\\s-")))
                     (delete-region (point) pt)
                   (unless (eq arg 0) (delete-char (1+ (- arg)))
                           (org-delete-char -1))))))
            (t (let ((pt (point)))
                 (if (not (eq 0 (skip-syntax-backward "\\s-")))
                     (delete-region (point) pt)
                   (unless (eq arg 0) (delete-char (1+ (- arg)))
                           (delete-char -1)))))))

    (defun lattie-flow ()
      (cond ((lattie--right-p)
             (cond ((string-prefix-p "\\begin{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                    (while (looking-at (concat "\\(\\s-*\\)" lattie-opening-environment-regexp-for-looking-at))
                      (delete-region (match-beginning 1) (match-end 1))
                      (insert-char ?\n)
                      (forward-char (- (match-end 0) (match-end 1))))
                    (delete-region (point) (progn (skip-syntax-forward "\\s-") (point)))
                    (insert-char ?\n 2)
                    (forward-char -1))
                   ((string-prefix-p "\\end{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                    (while (looking-back (concat lattie-closing-environment-regexp "\\s-*") (point-at-bol -1))
                      (re-search-backward lattie-closing-environment-regexp (point-at-bol -1) t)
                      (forward-char 1)
                      (delete-region (min (point)
                                          (progn (skip-chars-backward "\n")
                                                 (+ 2 (point))))
                                     (point))
                      (if (looking-back lattie-opening-environment-regexp-for-looking-at (point-at-bol) t)
                          (progn (insert-char ?\n 2)
                                 (forward-char -1))
                        (insert-char ?\n)
                        (forward-char -1))))
                   (t (re-search-backward lattie-closing-math-regexp nil t)
                      (forward-char 1))))
            ((lattie--left-p)
             (cond ((string-prefix-p "\\begin{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                    ;; (message "left : %s" (match-string-no-properties 0))
                    (forward-char (- (match-end 0) (match-beginning 0)))
                    (while (looking-at (concat "\\(\\s-+\\)" lattie-opening-environment-regexp-for-looking-at))
                      (delete-region (match-beginning 1) (match-end 1))
                      (insert-char ?\n)
                      (forward-char (- (match-end 0) (match-end 1))))
                    (delete-region (point) (progn (skip-syntax-forward "\\s-") (point)))
                    (insert-char ?\n 2)
                    (forward-char -1))
                   (t (re-search-forward lattie-opening-math-regexp nil t))))))

    (defun special-lattie-flow (arg)
      (interactive "p")
      (if (lattie--special-p)
          (lattie-flow)
        (lattie-self-insert-command arg)))

    (defun special-lattie-newline-and-indent ()
      (interactive)
      ;; (if (lattie--special-p)
      ;;     (lattie-forward 1)
      (org-return-indent)
      ;; )
      )

    (defun special-lattie-forward (arg)
      (interactive "p")
      (if (lattie--special-p)
          (lattie-forward arg)
        (lattie-self-insert-command arg)))

    (defun lattie-close-bracket (arg)
      (interactive "p")
      (cond ((and (looking-back "[^\\]\\\\" (1- (point-at-bol)) nil)
                  (or (looking-at "\\s-")
                      (eobp)))
             (lattie-self-insert-command arg))
            ((when-let ((context (and (memq major-mode '(org-mode
                                                         org-journal-mode))
                                      (org-element-context))))
               (cond ((and (eq 'headline (car context))
                           (eq (point)
                               (+ (org-element-property :level context)
                                  (org-element-property :begin context)
                                  1)))
                      (insert "[ ] "))
                     ((and (eq 'item (car context))
                           (eq (point)
                               (+ (org-element-property :begin context)
                                  (length (org-element-property :bullet context)))))
                      (insert "[ ] "))
                     (t (lattie-forward-or-eol arg)))))
            (t (lattie-forward-or-eol arg))))

    (defun lattie-forward-or-eol (arg)
      (if (and (eq (point)
                   (progn (lattie-forward arg)
                          (point))))
          (end-of-line)
        ""))

    (defun lattie-open-bracket (arg)
      (interactive "p")
      (cond ((looking-back "[^\\]\\\\" (1- (point-at-bol)) nil)
             (insert-char ?\[)
             (insert-char ?\\)
             (insert-char ?\])
             (let ((faces (get-text-property (point) 'face)))
               (put-text-property (- (point) 4)
                                  (point)
                                  'font-lock-face
                                  (cons 'font-latex-math-face faces)))
             (forward-char -2))
            (t (lattie-backward arg))))

    (defun special-lattie-dollar ()
      (interactive)
      (let ((lattie--special-p (lattie--special-p)))
        (cond ((and (not lattie--special-p)
                    (not (lattie--math-p))
                    (eq (char-before) ?\s)
                    (eq (char-before (1- (point))) ?$))
               (delete-char -1)
               (forward-char -1)
               (insert "\\,"))
              ((or (and (lattie--math-p)
                        (not lattie--special-p))
                   (and (eq (char-after) ?$)
                        (eq (char-before) ?$)))
               (insert-char ?\[)
               (insert-char ?\])
               (forward-char -1))
              (lattie--special-p
               (if (memq major-mode '(org-mode org-journal-mode))
                   (org-end-of-line)
                 (end-of-line)))
              (t (cdlatex-dollar)
                 (let ((faces (get-text-property (point) 'face)))
                   (put-text-property (1- (point))
                                      (1+ (point))
                                      'font-lock-face
                                      (cons 'font-latex-math-face faces)))))))

    (defun special-lattie-back-to-heading ()
      (interactive)
      (cond ((and (lattie--math-p)
                  (not (lattie--special-p)))
             (org-cdlatex-underscore-caret))
            ((org-at-heading-p)
             (org-up-element))
            (t (org-back-to-heading)
               (beginning-of-line))))

    (defun lattie-insert-dollar ()
      (interactive)
      (if (lattie--math-p)
          (insert "\\plus")
        (org-self-insert-command 1)))

    (defun special-lattie-open-brace ()
      (interactive)
      (cond ((looking-back "\\\\\\w*\\|[\\^\_]\\|\}" (point-at-bol) nil)
             (lattie-self-insert-command 1))
            ((search-backward "{" (point-at-bol) t)
             (forward-char 1)
             (push-mark (match-end 0) t t)
             (search-forward-regexp "\\\\\\{0,2\\}\}" (point-at-eol) t)
             (goto-char (match-beginning 0))
             (delete-selection-mode 0))))

    (defun special-lattie-close-brace ()
      (interactive)
      (cond ((looking-at "\\\\\\{1,2\\}\}")
             (goto-char (match-end 0))
             (deactivate-mark))
            ;; ((eq (char-after) ?\])
            ;;  (forward-char 1))
            ((looking-at "[\)\}]+")
             (skip-chars-forward "\)\]\}"))
            (t (lattie-self-insert-command 1))))

    (defun special-lattie-asterisk ()
      (interactive)
      (if (lattie--math-p)
          (lattie-self-insert-command 1)
        (if (looking-back "^\\**" (point-at-bol) nil)
            (lattie-self-insert-command 1)
          (lattie-self-insert-command 2)
          (forward-char -1))))

    (defun lattie-open-paren ()
      (interactive)
      (if (lattie--math-p)
          (progn (insert "()")
                 (forward-char -1))
        (lattie-self-insert-command 1)))

;;; Non-TeX tricks
    (defun lattieville-table-previous-row-or-eol ()
      (interactive)
      (if (org-at-table-p)
          (call-interactively #'+org/table-previous-row)
        (call-interactively #'org-end-of-line)))

    (defun lattie-ctrl-ret ()
      (interactive)
      (let ((direction 'below))
        (if (and (org-at-table-p)
                 (eq 1 (- (org-table-end)
                          (point))))
            (let* ((context
                    (save-excursion
                      (goto-char (org-table-begin))
                      (forward-char -1)
                      (when (bolp)
                        (back-to-indentation)
                        (forward-char))
                      (org-element-lineage
                       (org-element-context)
                       '(table table-row headline inlinetask item plain-list)
                       t)))
                   (type (org-element-type context)))
              (cond ((memq type '(item plain-list))
                     (let ((marker (org-element-property :bullet context))
                           (pad (save-excursion
                                  (org-beginning-of-item)
                                  (back-to-indentation)
                                  (- (point) (line-beginning-position)))))
                       (save-match-data
                         (pcase 'below
                           (`below
                            (org-end-of-item)
                            (backward-char)
                            (end-of-line)
                            (if (and marker (string-match "\\([0-9]+\\)\\([).] *\\)" marker))
                                (progn (goto-char (plist-get (cadr context) :end))
                                       (let ((l (line-number-at-pos pt)))
                                         (org-insert-item)
                                         (when (= l (line-number-at-pos))
                                           (org-next-item)
                                           (org-end-of-line))))
                              (insert "\n" (make-string pad 32) (or marker ""))))
                           (`above
                            (org-beginning-of-item)
                            (if (and marker (string-match-p "[0-9]+[).]" marker))
                                (org-insert-item)
                              (insert (make-string pad 32) (or marker ""))
                              (save-excursion (insert "\n")))))))
                     (when (org-element-property :checkbox context)
                       (insert "[ ] ")))

                    ((memq type '(table table-row))
                     (pcase direction
                       ('below (save-excursion (org-table-insert-row t))
                               (org-table-next-row))
                       ('above (save-excursion (org-shiftmetadown))
                               (+org/table-previous-row))))

                    ((memq type '(headline inlinetask))
                     (let ((level (if (eq (org-element-type context) 'headline)
                                      (org-element-property :level context)
                                    1)))
                       (pcase direction
                         (`below
                          (let ((at-eol (>= (point) (1- (line-end-position))))
                                org-insert-heading-respect-content)
                            (ignore org-insert-heading-respect-content)
                            (goto-char (line-end-position))
                            (org-end-of-subtree)
                            (insert (concat "\n"
                                            (when (= level 1)
                                              (if at-eol
                                                  (ignore (cl-incf level))
                                                "\n"))
                                            (make-string level ?*)
                                            " "))))
                         (`above
                          (org-back-to-heading)
                          (insert (make-string level ?*) " ")
                          (save-excursion
                            (insert "\n")
                            (if (= level 1) (insert "\n")))))
                       (when-let* ((todo-keyword (org-element-property :todo-keyword context)))
                         (org-todo (or (car (+org-get-todo-keywords-for todo-keyword))
                                       'todo)))))

                    (t (user-error "Not a valid list, heading or table")))
              (when (org-invisible-p)
                (org-show-hidden-entry)))
          (+org-insert-item 'below))))

    (defun special-lattie-space ()
      (interactive)
      (unless (and (eq (char-before) ?$)
                   (not (lattie--at-right-side-of-closing-expression?)))
        (when (looking-back "[\t\s\n],[a-zA-Z0-9,()]+" (point-at-bol) nil)
          (insert "$"
                  (buffer-substring (+ (match-beginning 0) 2)
                                    (match-end 0))
                  "$")
          (delete-region (1+ (match-beginning 0)) (match-end 0))))
      (if (and (eq (char-after) ?$)
               (not (lattie--at-left-side-of-opening-expression?)))
          (let ((faces (get-text-property (point) 'face)))
            (lattie-self-insert-command 1)
            (put-text-property (save-excursion (1+ (re-search-backward lattie-dollar-regexp nil t)))
                               (1+ (point))
                               'font-lock-face
                               '(font-latex-math-face)))
        (lattie-self-insert-command 1)))

    (defun special-lattie-punctuation ()
      (interactive)
      (if (and (eq (char-after) ?$)
               (not (lattie--at-left-side-of-opening-expression?)))
          (unless (and (eq (char-before) ?$)
                       (not (lattie--at-right-side-of-closing-expression?)))
            (when (looking-back "[\s\t\n],[a-zA-Z0-9,]+" (point-at-bol) nil)
              (insert "$"
                      (buffer-substring (+ (match-beginning 0) 2)
                                        (match-end 0))
                      "$")
              (delete-region (1+ (match-beginning 0)) (match-end 0))))
        (if (and (eq (char-before) ?$)
                 (lattie--at-right-side-of-closing-expression?))
            (progn (lattie-self-insert-command 1)
                   (put-text-property (1- (point))
                                      (point)
                                      'font-lock-face
                                      nil))
          (lattie-self-insert-command 1))))

    ;; (defun special-lattie-minus ()
    ;;   (interactive)
    ;;   (when (looking-back ",[a-zA-Z0-9]+" (point-at-bol) nil)
    ;;     (insert "$"
    ;;             (buffer-substring (1+ (match-beginning 0)) (match-end 0))
    ;;             "$")
    ;;     (delete-region (match-beginning 0) (match-end 0)))
    ;;   (if (fboundp 'typo-cycle-dashes)
    ;;       (typo-cycle-dashes 1)
    ;;     (lattie-self-insert-command 1)))

    (defun special-lattie-toggle-latex-fragment ()
      (interactive)
      (if (lattie--special-p)
          (org-toggle-latex-fragment)
        (lattie-self-insert-command 1)))

    (defun special-lattie-digit ()
      (interactive)
      (if (or (lattie--special-p)
              ;; (and (eq major-mode 'org-mode)
              ;;      (org-at-heading-or-item-p))
              )
          (call-interactively #'digit-argument)
        (lattie-self-insert-command 1)))

    (defun special-lattie-digit-or-bol (arg)
      (interactive "P")
      (if (or (lattie--special-p)
              ;; (and (eq major-mode 'org-mode)
              ;;      (org-at-heading-or-item-p))
              )
          (if arg
              (call-interactively #'digit-argument)
            (if (eq major-mode '(org-mode org-journal-mode))
                (org-beginning-of-line)
              (back-to-indentation)))
        (lattie-self-insert-command (or arg 1))))

    (defun special-lattie-compile ()
      (interactive)
      (if (lattie--special-p)
          (ignore-errors (org-export-dispatch))
        (lattie-self-insert-command 1)))

    (map! :map evil-org-mode-map
          "<return>" #'special-lattie-newline-and-indent
          [tab] #'org-cycle
          [C-return] #'lattie-ctrl-ret
          "C-n" #'org-table-next-row
          "C-e" #'lattieville-table-previous-row-or-eol
          "C-i" #'org-table-next-field
          "C-m" #'org-table-previous-field
          "C-j" nil
          "C-k" nil
          "C-l" nil
          "C-h" nil)

    (provide 'lattie)))
#+END_SRC
**** Add some extra things to LaTeX preview header
:PROPERTIES:
:CREATED_TIME: [2020-01-26 Sun 14:41]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (defvar org-format-latex-header-old org-format-latex-header)
  (setq org-format-latex-header (string-join `(,org-format-latex-header-old
                                               "\\DeclareMathOperator{\\Hom}{Hom}"
                                               "\\DeclareMathOperator{\\sSet}{sSet}"
                                               "\\DeclareMathOperator{\\Ob}{Ob}"
                                               )
                                             "\n")))
#+END_SRC
**** Use native font lock for LaTeX
:PROPERTIES:
:CREATED_TIME: [2020-01-25 Sat 17:07]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
   (setq org-highlight-latex-and-related '(native script entities)))
#+END_SRC
*** TODO Write down capture ideas and sort them afterwards
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:27]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! counsel-org-capture-string
  :commands (counsel-org-capture-string)
  :config
  ;; (ivy-add-actions
  ;;  'counsel-org-capture-string
  ;;  '(("sd" akirak/web-search-firefox "Default search with Firefox")
  ;;    ("sg" akirak/surfraw/google "Google")
  ;;    ("sl" akiraksearch/lucky "I'm Feeling Lucky")
  ;;    ("ss" akirak/helm-search "Choose a search engine")))
  ;; (defun akirak/counsel-org-capture ()
  ;;   (require 'org-capture)
  ;;   (require 'counsel-org-capture-string)
  ;;   (ivy-read "Capture template: "
  ;;             #'counsel-org-capture-string--template-list
  ;;             :action (lambda (x)
  ;;                       (org-capture nil (car (split-string x))))))
  ;; (advice-add #'counsel-org-capture :override #'akirak/counsel-org-capture)
  )
#+END_SRC
*** TODO Counsel org clock
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:33]
:END:
*** TODO org edna
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:35]
:END:
*** TODO poporg
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:37]
:END:
*** TODO org offtime
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 12:37]
:END:
** Email
*** Mu4e
**** Set up email accounts
#+BEGIN_SRC emacs-lisp :tangle yes
(set-email-account! "outlook"
                    `((mu4e-sent-folder . "/outlook/Sent Items")
                      (mu4e-drafts-folder . "/outlook/Drafts")
                      (mu4e-trash-folder . "/outlook/Trash")
                      (mu4e-refile-folder . "/outlook/Archive")
                      (smtpmail-smtp-user . ,user-mail-address)
                      (user-mail-address . ,user-mail-address))
                    t)
#+END_SRC
**** Set up keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(map! :leader
      :desc "Mu4e" "am" #'=mu4e)
#+END_SRC
**** Set unread email notifications
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! mu4e-alert
  :defer-incrementally t
  :config
  (defun my-mu4e-alert-mode-line-formatter (mail-count)
    "default formatter used to get the string to be displayed in the mode-line.
mail-count is the count of mails for which the string is to displayed"
    (when (not (zerop mail-count))
      (if (zerop mail-count)
          ""
        (format " [%d] " mail-count))))

  (mu4e-alert-set-default-style 'libnotify)

  (setq mu4e-alert-modeline-formatter #'my-mu4e-alert-mode-line-formatter
        mu4e-alert-notify-repeated-mails t
        mu4e-alert-email-notification-types '(subjects)
        mu4e-alert-interesting-mail-query "flag:unread AND NOT flag:trashed AND maildir:/outlook/Inbox")

  (mu4e-alert-enable-notifications)
  (mu4e-alert-enable-mode-line-display))
#+END_SRC
**** Automatically index mails
:PROPERTIES:
:CREATED_TIME: [2020-01-29 Wed 20:31]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (setq mu4e-update-interval 60
        mu4e-get-mail-command "true")) ;; Do not fetch mail.
#+END_SRC
**** Use mu4e-conversation interface
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (require 'mu4e-conversation)
  (setq mu4e-conversation-print-function 'mu4e-conversation-print-tree)
  (global-mu4e-conversation-mode +1))
#+END_SRC
**** Set up mu4e variables
:PROPERTIES:
:ID:       047a465b-7918-4590-9280-9b0b96893786
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (setq mu4e-save-multiple-attachments-without-asking t
        mu4e-compose-dont-reply-to-self t
        mu4e-headers-fields '(;; (:account . 12)
                              (:human-date . 12)
                              (:flags . 4)
                              ;; (:size . 6)
                              (:mailing-list . 16)
                              (:from . 28)
                              (:subject)))


  (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

  (setq mu4e-bookmarks
        `(,(make-mu4e-bookmark
            :name "Unread messages"
            :query "flag:unread AND NOT flag:trashed AND maildir:/outlook/Inbox"
            :key ?u)
          ,(make-mu4e-bookmark
            :name "Today's messages"
            :query "date:today..now AND NOT flag:trashed AND maildir:/outlook/Inbox"
            :key ?t)
          ,(make-mu4e-bookmark
            :name "Last 7 days"
            :query "date:7d..now AND NOT flag:trashed AND maildir:/outlook/Inbox"
            :key ?w)
          ,(make-mu4e-bookmark
            :name "Flagged"
            :query "maildir:/outlook/Inbox and flag:flagged"
            :key ?f)
          ,(make-mu4e-bookmark
            :name "Inbox"
            :query "maildir:/outlook/Inbox AND NOT flag:trashed"
            :key ?i)
          ,(make-mu4e-bookmark
            :name "Drafts"
            :query "flag:draft AND NOT flag:trashed"
            :key ?d))))
#+END_SRC
**** Make some emails stand out
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (set-face-foreground 'mu4e-unread-face "yellow")
  (set-face-attribute 'mu4e-flagged-face nil :inherit 'font-lock-warning-face))
#+END_SRC
**** Do not confirm on mark executions
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (defun ambrevar/mu4e-mark-execute-all-no-confirm ()
    (interactive)
    (mu4e-mark-execute-all t)
    ;; (+mu4e--refresh-current-view-a)
    )
  (define-key mu4e-headers-mode-map "x" 'ambrevar/mu4e-mark-execute-all-no-confirm)

  (when (featurep! :editor evil)
    (map! :map mu4e-headers-mode-map
          :n "x" #'ambrevar/mu4e-mark-execute-all-no-confirm)))
#+END_SRC
**** Set up org capture for email
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (when (require 'org-mu4e nil t)
    (dolist (map (list mu4e-view-mode-map mu4e-headers-mode-map))
      ;; Org mode has "C-c C-t" for 'org-todo.
      (define-key map (kbd "C-c C-t") 'org-mu4e-store-and-capture))
    (setq org-mu4e-link-query-in-headers-mode nil)

    (defun ambrevar/org-mail-date (&optional msg)
      (with-current-buffer (mu4e-get-headers-buffer)
        (mu4e-message-field (or msg (mu4e-message-at-point)) :date)))

    (add-to-list 'org-capture-templates
                 `("e" "Mark e-mail in agenda" entry ,(list 'file
                                                            (concat org-directory "email.org"))
                   "* TODO %?\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"++1d\" nil (ambrevar/org-mail-date)))\n%a\n"))))
#+END_SRC
:PROPERTIES:
:CREATED_TIME: [2020-01-15 Wed 13:53]
:END:
*** Attach files to email from Dired
#+BEGIN_SRC emacs-lisp :tangle yes
(after! dired
  (require 'gnus-dired)
  (after! gnus-dired
    ;; make the `gnus-dired-mail-buffers' function also work on
    ;; message-mode derived modes, such as mu4e-compose-mode
    (defun gnus-dired-mail-buffers ()
      "return a list of active message buffers."
      (let (buffers)
        (save-current-buffer
          (dolist (buffer (buffer-list t))
            (set-buffer buffer)
            (when (and (derived-mode-p 'message-mode)
                       (null message-sent-message-via))
              (push (buffer-name buffer) buffers))))
        (nreverse buffers)))
    (setq gnus-dired-mail-mode #'mu4e-user-agent)
    (add-hook 'dired-mode-hook #'turn-on-gnus-dired-mode)))
#+END_SRC
*** Contact database
**** Lazy load
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! bbdb
  :defer-incrementally t
  :config
  (require 'bbdb-message)
  (after! gnus
    (require 'ebdb-gnus))
  ;; (after! mu4e
  ;;   (require 'ebdb-mu4e))
  (bbdb-initialize 'gnus 'message))
#+END_SRC
**** Import and export .vcf files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! bbdb-vcard
  :commands (bbdb-vcard-import-file bbdb-vcard-export))
#+END_SRC
**** COMMENT Recognize bbdb links in Org mode
:PROPERTIES:
:CREATED_TIME: [2020-01-19 Sun 00:56]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! org
  (add-to-list 'org-modules 'org-bbdb))
#+END_SRC
*** COMMENT org-msg
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 15:02]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(remove-hook 'mu4e-compose-mode-hook #'org-mu4e-compose-org-mode)
(use-package! org-msg
  :after (mu4e smtpmail)
  :config
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil"
        org-msg-startup "hidestars indent inlineimages"
        org-msg-greeting-fmt "\nHi *%s*,\n\n"
        org-msg-greeting-name-limit 3
        org-msg-signature "

 Regards,

 ,#+begin_signature
 -- *Antonio* \\\\
 /One Emacs to rule them all/
 ,#+end_signature")
  (add-hook 'mu4e-compose-mode-hook #'org-msg-mode))
#+END_SRC
*** Preview emails
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 15:22]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! org-preview-html
  :commands (org-preview-html/preview
             org-preview-html-mode))
#+END_SRC
*** Use Helm to search & filter emails
:PROPERTIES:
:CREATED_TIME: [2020-01-18 Sat 20:15]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! mu4e
  (require 'helm-mu nil t)
  (add-hook! (mu4e-headers-mode
              mu4e-main-mode
              mu4e-view-mode)
    (map! :map (mu4e-headers-mode-map mu4e-main-mode-map mu4e-view-mode-map)
          :ne "s" #'helm-mu)))
#+END_SRC

#+RESULTS:

** Terminal
*** vterm
#+BEGIN_SRC emacs-lisp :tangle yes
(after! vterm
  (setq vterm-shell "/run/current-system/sw/bin/zsh"))
#+END_SRC
*** Eshell
**** Remove banner
#+BEGIN_SRC emacs-lisp :tangle yes
(after! esh-module
  (setq eshell-module-list
        (delq 'eshell-banner eshell-modules-list)))
#+END_SRC
**** Notify when external commands finish
:PROPERTIES:
:CREATED_TIME: [2020-01-16 Thu 15:04]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(after! eshell
  (require 'alert)

  (defun eshell-command-alert (process status)
    "Send `alert' with severity based on STATUS when PROCESS finished."
    (let* ((cmd (process-command process))
           (buffer (process-buffer process))
           (msg (format "%s: %s" (mapconcat 'identity cmd " ")  status)))
      (if (string-prefix-p "finished" status)
          (alert msg :buffer buffer :severity  'normal)
        (alert msg :buffer buffer :severity 'urgent))))

  (add-hook 'eshell-kill-hook #'eshell-command-alert)

  (alert-add-rule :status   '(buried)   ;only send alert when buffer not visible
                  :mode     'eshell-mode
                  :style 'notifications))
#+END_SRC

#+RESULTS:
| ((:status buried) (:mode . \`eshell-mode\')) | notifications | nil |

** PDF viewer
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package! pdf-tools
  :defer-incrementally t
  :magic ("%PDF" . pdf-view-mode)
  :config
  (setq pdf-misc-print-programm "/run/current-system/sw/bin/lpr")
  (setq pdf-misc-print-programm-args '("-P" "Brother_HL-L2320D_series"
                                       "-o" "media=letter"))
  (delq 'pdf-misc-size-indication-minor-mode pdf-tools-enabled-modes)
  (delq 'pdf-misc-context-menu-minor-mode pdf-tools-enabled-modes)
  (delq 'pdf-misc-menu-bar-minor-mode pdf-tools-enabled-modes)

  (when (featurep! :editor evil)
    (map! :map pdf-view-mode-map
          :n "J" #'pdf-view-next-page
          :n "K" #'pdf-view-previous-page)))
#+END_SRC
** Proof assistants
*** Proof general
#+BEGIN_SRC emacs-lisp :tangle yes
(after! proof-splash
  (setq proof-splash-enable nil))
(after! proof-useropts
  (setq proof-toolbar-enable nil))
#+END_SRC
*** Disable holes feature
#+BEGIN_SRC emacs-lisp :tangle yes
(after! pg-custom
  (setq coq-use-holes nil))
(after! coq-db
  (setq coq-holes-minor-mode nil))
(advice-add #'coq-build-abbrev-table-from-db :override #'ignore)
#+END_SRC
*** Coq
#+BEGIN_SRC emacs-lisp :tangle yes
(after! company-coq
  (setq company-coq-live-on-the-edge t
        company-coq-disabled-features '(hello)))
#+END_SRC
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda nil (byte-compile-file
# (concat (string-remove-suffix "org" (buffer-file-name)) "el"))) 'append 'local)
# before-save-hook: org-make-toc
# End:
** Lispy
*** Error about cider-start-map
:PROPERTIES:
:CREATED_TIME: [2020-02-02 Sun 11:33]
:END:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (featurep! :editor lispy)
  (autoload 'cider-start-map "cider" "CIDER jack-in and connect keymap." t 'keymap))
#+END_SRC
