;;; ~/.doom.d/lattie.el -*- lexical-binding: t; -*-

(require 'org-element)
(require 'texmathp)
(require 'cdlatex)
(require 'typo)

(when (not (featurep 'lispy))
  (defmacro lispy-dotimes (n &rest bodyform)
    "Execute N times the BODYFORM unless an error is signaled.
Return nil if couldn't execute BODYFORM at least once.
Otherwise return the amount of times executed."
    (declare (indent 1)
             (debug (form body)))
    `(let ((i 0))
       (catch 'result
         (condition-case e
             (progn
               (while (<= (cl-incf i) ,n)
                 ,@bodyform)
               ,n)
           (error
            (when (eq (car e) 'buffer-read-only)
              (message "Buffer is read-only: %s" (current-buffer)))
            (cl-decf i)
            (and (> i 0) i)))))))

(defvar lattie-dollar-regexp "[^\\]\\$")
(defvar lattie-dollar-regexp-for-looking-at "\\$")

(defvar lattie-closing-math-regexp
  (concat lattie-dollar-regexp
          "\\|[^\\]\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-closing-math-regexp-for-looking-at
  (concat lattie-dollar-regexp-for-looking-at
          "\\|\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-opening-math-regexp
  (concat lattie-dollar-regexp
          "\\|[^\\]\\\\\\(\\\[\\|\(\\|begin\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-opening-math-regexp-for-looking-at
  (concat lattie-dollar-regexp-for-looking-at
          "\\|\\\\\\(\\\[\\|\(\\|begin\{[^\\s$\\s-]+\}\\)"))

(defvar lattie-closing-math-regexp-with-whitespace
  (concat "\\s-*"
          lattie-dollar-regexp
          "\\|[^\\]\\\\\\(\\s-*\]\\|\\s-*\)\\|\\s-*end\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-closing-math-regexp-with-whitespace-for-looking-at
  (concat "\\s-*"
          lattie-dollar-regexp-for-looking-at
          "\\|[^\\]\\\\\\(\\s-*\]\\|\\s-*\)\\|\\s-*end\{[^\\s$\\s-]+\}\\)"))

(defvar lattie-opening-math-regexp-with-whitespace
  (concat lattie-dollar-regexp
          "\\s-*\\|[^\\]\\\\\\(\\\[\\s-*\\|\(\\s-*\\|begin\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-opening-math-regexp-with-whitespace-for-looking-at
  (concat lattie-dollar-regexp-for-looking-at
          "\\s-*\\|\\\\\\(\\\[\\s-*\\|\(\\s-*\\|begin\{[^\\s$\\s-]+\}\\)"))

(defvar lattie-closing-or-environment-math-regexp
  (concat lattie-dollar-regexp
          "\\|[^\\]\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-closing-or-environment-math-regexp-for-looking-at
  (concat lattie-dollar-regexp-for-looking-at
          "\\|\\\\\\(\]\\|\)\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))

(defvar lattie-opening-or-environment-math-regexp
  (concat lattie-dollar-regexp
          "\\|[^\\]\\\\\\(\\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-opening-or-environment-math-regexp-for-looking-at
  (concat lattie-dollar-regexp-for-looking-at
          "\\|\\\\\\(\\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))

(defvar lattie-closing-or-opening-math-regexp
  (concat lattie-dollar-regexp
          "\\|[^\\]\\\\\\(\]\\|\)\\|\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))
(defvar lattie-closing-or-opening-math-regexp
  (concat lattie-dollar-regexp-for-looking-at
          "\\|\\\\\\(\]\\|\)\\|\[\\|\(\\|end\{[^\\s$\\s-]+\}\\|begin\{[^\\s$\\s-]+\}\\)"))

(defvar lattie-closing-environment-regexp "[^\\]\\\\end\{\\([^\\s$\\s-]+\\)\}")
(defvar lattie-closing-environment-regexp-for-looking-at "\\\\end\{\\([^\\s$\\s-]+\\)\}")
(defvar lattie-opening-environment-regexp "[^\\]\\\\begin\{\\([^\\s$\\s-]+\\)\}")
(defvar lattie-opening-environment-regexp-for-looking-at "\\\\begin\{\\([^\\s$\\s-]+\\)\}")
(defvar lattie-open-or-close-environment-regexp "[^\\]\\\\end\{[^\\s$\\s-]+\}\\|[^\\]\\\\begin\{[^\\s$\\s-]+\}")
(defvar lattie-open-or-close-environment-regexp-for-looking-at "\\\\end\{[^\\s$\\s-]+\}\\|\\\\begin\{[^\\s$\\s-]+\}")

(defvar lattie-debug nil)
(defvar lattie--left-matched? nil)

(defconst english-punctuation '(?, ?. ?! ?\? ?\; ?…))

(defun lattie--math-p (&optional pt)
  (let* ((pt-old (or pt (point)))
         (pt-new (if (and (eq (char-after pt-old) ?\n)
                          (not (eq (char-before (1- pt-old)) ?$)))
                     (1- pt-old)
                   pt-old))
         (face-at-pt (get-text-property (or pt-new (point)) 'face)))
    (or (and (listp face-at-pt)
             (or (memq 'org-latex-and-related face-at-pt)
                 (memq 'font-latex-math-face face-at-pt)
                 (memq 'font-latex-sedate-face face-at-pt)
                 (memq 'font-function-function-name-face face-at-pt)
                 (memq 'tex-math face-at-pt)
                 (memq 'endless/unimportant-latex-face face-at-pt)
                 ;; (memq 'rainbow-delimiters-depth-1-face face-at-pt)
                 ;; (memq 'rainbow-delimiters-depth-2-face face-at-pt)
                 ;; (memq 'rainbow-delimiters-depth-3-face face-at-pt)
                 ;; (memq 'rainbow-delimiters-depth-4-face face-at-pt)
                 ))
        (eq face-at-pt 'tex-math))))

(defun lattie--left-p ()
  (or (and (looking-at lattie-opening-math-regexp-for-looking-at)
           (or (not (eq (char-after) ?$))
               (eq (char-before) ?\n)
               (lattie--at-left-side-of-opening-expression?))
           (or (not (eq (char-after) ?$))
               (eq (char-before) ?\n)
               (not (looking-back lattie-closing-math-regexp (point-at-bol) nil))))
      (looking-at lattie-open-or-close-environment-regexp-for-looking-at)))

(defun lattie--right-p (&rest _)
  (or (and (looking-back lattie-closing-math-regexp (point-at-bol) nil)
           (or (not (eq (char-before) ?$))
               (eq (char-after) ?\n)
               (lattie--at-right-side-of-closing-expression?))
           (or (not (eq (char-before) ?$))
               (eq (char-after) ?\n)
               (not (looking-at lattie-opening-math-regexp-for-looking-at))))
      (looking-back lattie-open-or-close-environment-regexp (point-min) nil)))

(defmacro lattie-stay-special (&rest forms)
  `(let ((pt (point)))
     ,@forms
     (while (and (not (eq (point) pt))
                 (or (eq (char-before) ?\\)
                     ;; (looking-back "\\\\]" (- (point) 3))
                     (invisible-p (point))
                     (looking-back "\\\\\\\\\\\(\)\\|\]\\)" (- (point) 3))))
       ,@forms
       (setq pt (point)))
     (when (or (eq (point) ,(point))
               (eq (char-before) ?\\)
               ;; (looking-back "\\\\)" (- (point) 3))
               ;; (looking-back "\\\\]" (- (point) 3))
               (invisible-p (point))
               (looking-back "\\\\\\\\\\\(\)\\|\]\\)" (- (point) 3)))
       (goto-char ,(point)))))

(defun lattie--at-left-side-of-opening-expression? ()
  (save-excursion
    (not (lattie--math-p
          (progn (re-search-backward "[^\\s.]" nil t)
                 ;; (re-search-backward "[^\\sw]" nil t)
                 (while (eq (char-before) ?\\)
                   (forward-char -1))
                 (point))))))

(defun lattie--at-right-side-of-closing-expression? ()
  (save-excursion
    (and (not (and (eq (char-after) ?$)
                   (eq (- (point-max) (point))
                       1)))
         (or (and (eq (char-before) ?$)
                  (eq (char-after) ?\n))
             (not (lattie--math-p
                   (progn (unless (or (looking-at "[^\s.\$]+\\$")
                                      (and (eq (char-before) ?$)
                                           (eq (char-after) ?$)))
                            (re-search-forward "[^\\s.]" nil t))
                          (while (eq (char-before) ?\\)
                            (forward-char -1))
                          (point))))))))

(defun lattie--special-p (&rest _)
  (or (lattie--left-p)
      (lattie--right-p)))

(defun lattie--not-special-p (&rest _)
  (not (lattie--special-p)))

(defun lattie--not-math-p (&rest _)
  (not (lattie--math-p)))

(defun lattie--math-p-ignore-args (&rest _)
  (lattie--math-p))

(defun lattie--get-forward-limit ()
  (save-excursion
    (if (looking-back lattie-opening-environment-regexp (1- (point-at-bol)) nil)
        (goto-char (match-beginning 0))
      (forward-char -1))
    ;; (message "initial: %s %s" (match-string 0) (match-string 1))
    (let* ((limit (save-excursion (re-search-forward lattie-closing-math-regexp nil t)))
           (match (match-data))
           (op (re-search-forward lattie-opening-environment-regexp limit t))
           (new-limit? (and (match-string-no-properties 1)
                            ;; (message "%s" (match-string-no-properties 1))
                            (save-excursion
                              (re-search-forward
                               (concat "[^\\]\\\\end{\\("
                                       (regexp-quote (match-string-no-properties 1))
                                       "\\)}")
                               nil
                               t)))))
      (unless new-limit? (set-match-data match))
      ;; (message "limits: %s %s %s %s" limit new-limit? op (match-string-no-properties 1))
      (when (match-string-no-properties 1)
        (while (and (integerp op)
                    (integerp new-limit?)
                    (integerp limit)
                    (< op limit)
                    (< limit new-limit?))
          (setq limit new-limit?
                match (match-data)
                op (re-search-forward lattie-opening-environment-regexp limit t)
                new-limit? (save-excursion
                             (re-search-forward
                              (concat "[^\\]\\\\end{\\("
                                      (regexp-quote (match-string-no-properties 1))
                                      "\\)}")
                              nil
                              t)))
          ;; (message "new limit: %s %s %s" limit new-limit? op)
          ))
      (set-match-data match)
      ;; (message "final limit: %s %s" limit (match-string 0))
      limit)))

;; (defun lattie--get-backward-limit ()
;;   (save-excursion
;;     (if (looking-at lattie-closing-environment-regexp-for-looking-at)
;;         (goto-char (match-end 0))
;;       (forward-char -1))
;;     ;; (message "initial: %s %s" (match-string 0) (match-string 1))
;;     (let* ((limit (save-excursion (re-search-backward lattie-opening-math-regexp nil t)))
;;            (match (match-data))
;;            (cl (re-search-backward lattie-closing-environment-regexp limit t))
;;            (new-limit? (and (match-string-no-properties 1)
;;                             ;; (message "%s" (match-string-no-properties 1))
;;                             (save-match-data
;;                               (re-search-backward
;;                                (concat "[^\\]\\\\begin{"
;;                                        (regexp-quote (match-string-no-properties 1))
;;                                        "}")
;;                                nil
;;                                t)))))
;;       ;; (message "limits: %s %s %s %s" limit new-limit? op (match-string-no-properties 1))
;;       (when (match-string-no-properties 1)
;;         (while (and (integerp cl)
;;                     (integerp new-limit?)
;;                     (integerp limit)
;;                     (> op limit)
;;                     (> limit new-limit?))
;;           (setq limit new-limit?
;;                 match (match-data)
;;                 op (re-search-backward lattie-closing-environment-regexp limit t)
;;                 new-limit? (save-excursion
;;                              (re-search-backward
;;                               (concat "[^\\]\\\\begin{"
;;                                       (regexp-quote (match-string-no-properties 1))
;;                                       "}")
;;                               nil
;;                               t)))
;;           ;; (message "new limit: %s %s %s" limit new-limit? op)
;;           ))
;;       (set-match-data match)
;;       limit)))

(defun lattie-forward (arg)
  (interactive "p")
  (lispy-dotimes arg
    (lattie--trim-whitespace-right)
    (lattie--get-forward-limit)
    (forward-char -1)
    (if (eq (point)
            (progn (cond ((string-prefix-p "\\end{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                          (goto-char (match-end 0)))
                         ((re-search-forward lattie-closing-math-regexp nil t)
                          (when (not (lattie--right-p))
                            (re-search-forward lattie-closing-math-regexp nil t)))
                         ((eq (char-after) ?\})
                          (forward-char 1)))
                   (point)))
        (progn (lattie--trim-whitespace-right)
               (forward-char 1))
      (lattie--trim-whitespace-right))))

(defmacro lattie-dotimes (n &rest forms)
  `(dotimes (_i ,n)
     ,@forms))

(defun lattie-backward (arg)
  (interactive "p")
  (lispy-dotimes arg
    (if (looking-back lattie-closing-environment-regexp (1- (point-at-bol)) nil)
        (re-search-backward (concat "\\\\begin\{"
                                    (regexp-quote (match-string-no-properties 1))
                                    "}")
                            nil
                            t)
      (lattie-stay-special (re-search-backward lattie-opening-math-regexp nil t)
                           (forward-char 1))
      (when (not (lattie--left-p))
        (lattie-stay-special
         (re-search-backward lattie-opening-math-regexp nil t)
         (forward-char 1))))
    ;; (lattie--trim-whitespace-left)
    ))

(defun lattie--trim-whitespace-right ()
  (cond ((eq (char-before) ?$)
         (forward-char -1)
         (let* ((end (point))
                (offset (skip-syntax-backward "\\s-"))
                (s (buffer-substring-no-properties (+ end offset) end)))
           (unless (progn (delete-region (+ end offset) end)
                          (forward-char 1)
                          (prog1 (lattie--at-right-side-of-closing-expression?)
                            (forward-char -1)))
             (insert s)))
         (forward-char 1))))

;; (defun lattie--trim-whitespace-left ()
;;   (cond ((eq (char-after) ?$)
;;          (forward-char 1)
;;          (let* ((beg (point))
;;                 (offset (skip-syntax-forward "\\s-"))
;;                 (s (buffer-substring-no-properties (+ beg offset) beg)))
;;            (unless (progn (delete-region beg (+ beg offset))
;;                           (lattie--at-left-side-of-opening-expression?))
;;              (insert s)))
;;          (forward-char -1))))

(defun lattie--debug (&rest args)
  (when lattie-debug
    (apply #'message args)))

(defun lattie-right (arg)
  "FIXME Maybe I should just remove this."
  (skip-syntax-backward "\\s-" (point-at-eol))
  (lispy-dotimes arg
    (unless (lattie--at-right-side-of-closing-expression?)
      (cond ((looking-at lattie-opening-environment-regexp-for-looking-at)
             (goto-char (match-end 0)))
            (t (lattie-forward 1))))))

(defun lattie-left (arg)
  "FIXME Maybe I should just remove this"
  (let ((pt (point)))
    (skip-syntax-backward "\\s-" (point-at-bol))
    (when (eq (point)
              (progn (lispy-dotimes arg
                       (unless (and (lattie--at-left-side-of-opening-expression?)
                                    (not (looking-at lattie-open-or-close-environment-regexp-for-looking-at)))
                         (cond ((looking-at lattie-open-or-close-environment-regexp-for-looking-at)
                                (goto-char (match-end 0))
                                (lattie-backward 1))
                               ((looking-back lattie-closing-environment-regexp (1- (point-at-bol)) t)
                                (goto-char (1+ (match-beginning 0))))
                               (t (lattie-backward 1)))))
                     (point)))
      (goto-char pt))))

(defun lattie-up (arg)
  (let ((data nil)
        (pt (point)))
    (lispy-dotimes arg
      (lattie--special-p)
      (cond ((or (string-prefix-p "\\end\{" (match-string-no-properties 0))
                 (string-prefix-p "\\begin\{" (match-string-no-properties 0)))
             (if (looking-at lattie-open-or-close-environment-regexp-for-looking-at)
                 (progn (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                        (forward-char 1)
                        (when (string-suffix-p "$" (match-string-no-properties 0))
                          (re-search-backward lattie-opening-or-environment-math-regexp nil t)
                          (forward-char 1)))
               (re-search-backward lattie-closing-or-environment-math-regexp nil t)
               (re-search-backward lattie-closing-or-environment-math-regexp nil t)
               (when (string-suffix-p "$" (match-string-no-properties 0))
                 (re-search-forward lattie-closing-math-regexp nil t))
               (goto-char (match-end 0))))
            ((eq (char-before) ?$)
             (save-excursion (re-search-backward lattie-closing-math-regexp nil t))
             (when (string-suffix-p "$" (match-string-no-properties 0))
               (progn (goto-char (1+ (match-beginning 0)))
                      (setq data (match-data))
                      (re-search-backward lattie-closing-math-regexp nil t)
                      (re-search-backward lattie-closing-math-regexp nil t)))
             (goto-char (match-end 0))
             (when (and (eq (char-before) ?$)
                        (not (lattie--right-p)))
               (set-match-data data)
               (goto-char (match-end 0))))
            ((lattie--right-p)
             (goto-char (1+ (match-beginning 0)))
             (re-search-backward lattie-closing-or-environment-math-regexp nil t)
             (goto-char (match-end 0)))
            ((lattie--left-p)
             (re-search-backward lattie-opening-or-environment-math-regexp nil t)
             (unless (equal (match-string-no-properties 0) "\n")
               (goto-char (1+ (match-beginning 0))))
             (when (string-suffix-p "$" (match-string-no-properties 0))
               (progn (goto-char (match-beginning 0))
                      (re-search-backward lattie-closing-or-environment-math-regexp nil t)
                      (forward-char 1))))))
    (when (< pt (point))
      (goto-char pt))))

(defun lattie-down (arg)
  (let ((data nil)
        (pt (point)))
    (lispy-dotimes arg
      (lattie--special-p)
      (cond ((or (string-match-p "\\\\end\{" (match-string-no-properties 0))
                 (string-match-p "\\\\begin\{" (match-string-no-properties 0)))
             (if (looking-at lattie-open-or-close-environment-regexp-for-looking-at)
                 (progn (goto-char (match-end 0))
                        (re-search-forward lattie-closing-or-environment-math-regexp nil t)
                        (goto-char (1+ (match-beginning 0))))
               (goto-char (match-end 0))
               ;; I am currently at the right side of \\begin/end{...} statement
               (re-search-forward lattie-open-or-close-environment-regexp nil t)
               (when (string-suffix-p "$" (match-string-no-properties 0))
                 (progn (goto-char (match-end 0))
                        (setq data (match-data))
                        (re-search-forward lattie-closing-math-regexp nil t)))))
            ((eq (char-before) ?$)
             (save-excursion (re-search-forward lattie-closing-or-opening-math-regexp nil t))
             (setq data (match-data))
             (when (string-suffix-p "$" (match-string-no-properties 0))
               (progn (goto-char (match-end 0))
                      (setq data (match-data))
                      (re-search-forward lattie-closing-math-regexp nil t)))
             (goto-char (match-end 0))
             (when (and (eq (char-before) ?$)
                        (not (lattie--right-p)))
               (set-match-data data)
               (goto-char (match-end 0))))
            ((eq (char-after) ?$)
             (forward-char 1)
             (re-search-forward lattie-opening-or-environment-math-regexp nil t)
             (when (string-match-p "\$$" (match-string-no-properties 0))
               (progn (goto-char (match-end 0))
                      (re-search-forward lattie-opening-or-environment-math-regexp nil t)
                      (goto-char (1+ (match-beginning 0)))))
             )
            ((lattie--right-p)
             (goto-char (match-end 0))
             (re-search-forward lattie-closing-or-environment-math-regexp nil t)
             (when (string-suffix-p "$" (match-string-no-properties 0))
               (progn (goto-char (match-end 0))
                      (setq data (match-data))
                      (re-search-forward lattie-opening-or-environment-math-regexp nil t))))
            ((lattie--left-p)
             (goto-char (match-end 0))
             (re-search-forward lattie-opening-or-environment-math-regexp nil t)
             (goto-char (match-beginning 0)))))
    (when (<= (1- (point)) pt)
      (goto-char pt))))

;; (defun lattie-up (arg)
;;   (interactive "p")
;;   (cond ((lattie--left-p)
;;          (lattie-backward arg)
;;          (lattie-left 1))
;;         ((lattie--right-p)
;;          (lattie-backward (1+ arg))
;;          (lattie-right 1))))

(defun lattie--char-before-is-not-whitespace-p (&rest _)
  (not (eq (char-syntax (char-before))
           ?\s)))

(defun lattie--is-english-punctuation-p (c)
  (memq c english-punctuation))

(defun lattie-self-insert-command (arg)
  (interactive "p")
  (when (looking-back lattie-closing-math-regexp (point-at-bol))
    (put-text-property (1- (point))
                       (point)
                       'font-lock-face
                       nil))
  (lattie--skip-past-deadline)
  (lattie--skip-past-property-drawer)
  (when (looking-back org-property-end-re (point-at-bol))
    (if (looking-at "\n\n")
        (forward-char 1)
      (insert-char ?\n)))
  (if (memq major-mode '(org-mode org-journal-mode))
      (pcase (aref (this-command-keys-vector) 0)
        (?- (if (bolp)
                (insert "- ")
              (org-self-insert-command arg)))
        ((and (or (pred lattie--not-math-p)
                  (pred lattie--right-p))
              (pred lattie--char-before-is-not-whitespace-p)
              (pred lattie--is-english-punctuation-p)
              (pred lattie--not-math-shorthand-p))
         (org-self-insert-command arg)
         (setq unread-input-method-events '(32)))
        (?. (if (looking-back "\\. ?")
                (progn (delete-region (match-beginning 0) (match-end 0))
                       (insert "… "))
              (org-self-insert-command arg)))
        (?= (if (lattie--math-shorthand-p)
                (insert "=")
              (org-self-insert-command arg)))
        (?\; (cond ((lattie--math-p)
                    (insert ": ")
                    (let ((faces (get-text-property (point) 'face)))
                      (put-text-property (1- (point))
                                         (1+ (point))
                                         'font-lock-face
                                         (cons 'font-latex-math-face faces))))
                   ((lattie--math-shorthand-p)
                    (insert ":"))
                   ((equal (buffer-substring-no-properties (- (point) 2)
                                                           (point))
                           "$ ")
                    (save-excursion (forward-char -1)
                                    (insert-char ?\;)))
                   (t (org-self-insert-command arg))))
        (?\) (if-let* ((parsed-syntax (syntax-ppss))
                       (op (second (syntax-ppss)))
                       (in-top-sexp-p (and (integerp op)
                                           (string-match-p "[\s\t\n],"
                                                           (buffer-substring-no-properties (- op 2)
                                                                                           op))))
                       (math-shorthand-p (progn (forward-char 1)
                                                (lattie--math-shorthand-p))))
                 (progn (lattie--apply-math-shorthand-before-point)
                        (unless (eq (char-before) ?\n)
                          (insert " ")))
               (org-self-insert-command arg)))
        ((and (pred lattie--math-p-ignore-args)
              (pred lattie--looking-back-at-math-symbol-p))
         (insert " " (this-command-keys)))
        (_ (org-self-insert-command arg)))
    (self-insert-command arg)))

(defun lattie--looking-back-at-math-symbol-p (&rest _)
  (looking-back "[ \n\t\\$\"\[\\({]\\\\[a-zA-Z]+"))

(defun lattie--not-math-shorthand-p (&rest _)
  (not (lattie--math-shorthand-p)))

(defun lattie--skip-past-property-drawer ()
  (when (string-match-p org-property-start-re (buffer-substring-no-properties (point-at-bol)
                                                                              (point-at-eol)))
    (re-search-forward org-property-end-re)))

(defun lattie--skip-past-deadline ()
  (when (string-match-p org-deadline-regexp (buffer-substring-no-properties (point-at-bol)
                                                                            (point-at-eol)))
    (forward-line 1)))

;; (defun lattie--skip-backwards-past-property-drawer ()
;;   (when (save-excursion (when (eq (char-before) ?\n)
;;                           (forward-char -1))
;;                         (looking-back org-property-end-re (point-at-bol)))
;;     (re-search-backward org-property-start-re)
;;     (forward-char -1)))

(defun lattie--skip-backwards-past-deadline ()
  (when (save-excursion (when (eq (char-before) ?\n)
                          (forward-char -1))
                        (string-match-p org-deadline-regexp (buffer-substring-no-properties (point-at-bol)
                                                                                            (point-at-eol))))
    (forward-line -1)))

(defun special-lattie-grave ()
  (interactive)
  (cond ((lattie--math-p)
         (progn (unless (or (memq (char-before) '(?\s ?\t ?\n ?\{ ?\( ?\[ ?$ ?\"))
                            (equal (this-command-keys-vector)
                                   [?\']))
                  (insert-char ?\s))
                (if (equal (this-command-keys-vector)
                           [?\`])
                    (progn (call-interactively #'cdlatex-math-symbol)
                           (when (equal (buffer-substring-no-properties (- (point) 7)
                                                                        (point))
                                        " \\prime")
                             (forward-char -7)
                             (delete-char 1)
                             (forward-char 6)))
                  (call-interactively #'cdlatex-math-modify))))
        ((lattie--math-shorthand-p)
         (if (equal (this-command-keys-vector)
                    [?\`])
             (insert-char ?\`)
           (insert-char ?\')))
        (t (org-self-insert-command 1))))

(defun special-lattie-underscore-caret ()
  (interactive)
  (expand-abbrev)
  (cond ((lattie--math-shorthand-p)
         (insert (this-command-keys)
                 "{}")
         (forward-char -1))
   (t (org-cdlatex-underscore-caret))))

(defun special-lattie-backward (arg)
  (interactive "p")
  (if (lattie--special-p)
      (lattie-backward arg)
    (lattie-self-insert-command arg)))

(defun special-lattie-up (arg)
  (interactive "p")
  (cond ((lattie--special-p)
         (lattie-stay-special (lattie-up arg)))
        ;; ((and (eq major-mode 'org-mode)
        ;;       (org-at-heading-p))
        ;;  (org-next-visible-heading arg))
        ;; ((and (eq major-mode 'org-mode)
        ;;       (org-at-item-p))
        ;;  (lispy-dotimes arg (org-next-item)))
        (t (lattie-self-insert-command arg))))

(defun special-lattie-down (arg)
  (interactive "p")
  (cond ((lattie--special-p)
         (lattie-stay-special (lattie-down arg)))
        ;; ((and (eq major-mode 'org-mode)
        ;;       (org-at-heading-p))
        ;;  (org-next-visible-heading arg))
        ;; ((and (eq major-mode 'org-mode)
        ;;       (org-at-item-p))
        ;;  (lispy-dotimes arg (org-next-item)))
        (t (lattie-self-insert-command arg))))

(defun special-lattie-left (arg)
  (interactive "p")
  (cond ((lattie--special-p)
         (lattie-left arg))
        ;; ((and (eq major-mode 'org-mode)
        ;;       (org-at-heading-or-item-p))
        ;;  (org-up-element))
        (t (lattie-self-insert-command arg))))

(defun special-lattie-right (arg)
  (interactive "p")
  (cond ((lattie--special-p)
         (lattie-right arg))
        ;; ((and (eq major-mode 'org-mode)
        ;;       (org-at-heading-or-item-p))
        ;;  (org-down-element))
        (t (lattie-self-insert-command arg))))

(defun lattie-delete-backward (arg)
  (interactive "p")
  (cond (mark-active
         (kill-region (mark) (point)))
        ((and (eq (char-after) ?$)
              (eq (char-before) ?$))
         (delete-char 1)
         (delete-char -1))
        ((and (looking-at "\\(\\\\\\{0,2\\}\\)\\(\)\\|\\]\\|\}\\)")
              (looking-back (concat (regexp-quote (match-string-no-properties 1))
                                    (regexp-quote (cond ((equal (match-string-no-properties 2) ")")
                                                         (identity "("))
                                                        ((equal (match-string-no-properties 2) "]")
                                                         (identity "["))
                                                        ((equal (match-string-no-properties 2) "}")
                                                         (identity "{")))))
                            (point-at-bol)
                            nil))
         (delete-region (- (point) (- (match-end 0) (match-beginning 0)))
                        (+ (point) (- (match-end 0) (match-beginning 0)))))
        ((and (not (lattie--math-p))
              (eq (char-before) (char-after))
              (memq (char-before) '(?* ?/ ?=)))
         (delete-region (1- (point)) (1+ (point))))
        ((and (eq (char-before) (char-before (1- (point))))
              (memq (char-before) '(?* ?/ ?=))
              (not (lattie--math-p)))
         (if (and (memq major-mode '(org-mode org-journal-mode))
                  (looking-back "^\\*+" (point-at-bol) nil))
             (org-delete-char -1)
           (delete-region (- (point) 2) (point))))
        ((looking-back "\\\\\\{0,2\\}\{\\\\\\{0,2\\}\}" (point-at-bol) nil)
         (delete-region (match-beginning 0) (match-end 0)))
        ((looking-back "\\\\\\{0,2\\}\\[\\\\\\{0,2\\}\\]" (point-at-bol) nil)
         (delete-region (match-beginning 0) (match-end 0)))
        ((looking-back "\\\\\\{0,2\\}\(\\\\\\{0,2\\}\)" (point-at-bol) nil)
         (delete-region (match-beginning 0) (match-end 0)))
        ((lattie--right-p)
         (cond ((and              ;(message "%s" (match-string-no-properties 0))
                 (string-prefix-p "\\begin{" (substring-no-properties (match-string-no-properties 0) 1 nil))))
               ((and              ;(message "%s" (match-string-no-properties 0))
                 (string-prefix-p "\\end{" (substring-no-properties (match-string-no-properties 0) 1 nil)))
                (kill-region (save-match-data
                               (re-search-backward
                                (regexp-quote (concat "\\begin{"
                                                      (substring-no-properties (match-string-no-properties 0)
                                                                               6
                                                                               (- (match-end 0) (match-beginning 0) 1))
                                                      "}"))
                                nil))
                             (match-end 0)))
               (t (apply #'kill-region
                         (nreverse (list (point)
                                         (progn (lattie-left arg) (point))))))))
        ((and (looking-back "\\\\begin\{\\([^\s$\s-]+\\)\}" (point-at-bol) nil)
              (match-string-no-properties 1)
              (equal (regexp-quote (match-string-no-properties 1))
                     (and (looking-at "\n?\\\\end\{\\([^\s$\s-]+\\)\}")
                          (match-string-no-properties 1))))
         (delete-region (match-beginning 0)
                        (match-end 0))
         (delete-region (point)
                        (re-search-backward "\\\\begin\{\\([^\s$\s-]+\\)\}")))
        ((and (lattie--math-p)
              (lattie--looking-back-at-math-symbol-p))
         (delete-region (1+ (match-beginning 0)) (match-end 0)))
        ((memq major-mode '(org-mode org-journal-mode))
         (if-let ((context (and (memq major-mode '(org-mode org-journal-mode))
                                (org-element-context))))
             (cond ((and (eq (car context) 'item)
                         (org-element-property :checkbox context)
                         (< (- (point) (org-element-property :begin context)) 7))
                    (delete-region (point) (+ (org-element-property :begin context)
                                              (length (org-element-property :bullet context)))))
                   ((and (eq (car context) 'item)
                         (org-element-property :bullet context)
                         (= (point) (+ (org-element-property :begin context)
                                       (length (org-element-property :bullet context)))))
                    (delete-region (point) (org-element-property :begin context)))
                   ((and (eq (car context) 'headline)
                         (org-element-property :todo-keyword context)
                         (< (- (point)
                               (length (org-element-property :todo-keyword context))
                               (org-element-property :level context)
                               (org-element-property :begin context))
                            3))
                    (delete-region (point)
                                   (+ (org-element-property :begin context)
                                      (org-element-property :level context)
                                      1)))
                   (t (let ((pt (point)))
                        (if (not (eq 0 (skip-syntax-backward "\\s-" (point-at-bol 0))))
                            (let ((s (buffer-substring-no-properties (point) pt)))
                              (delete-region (point) pt)
                              (when (and (not (string-match-p "\n" s))
                                         (lattie--is-english-punctuation-p (char-before)))
                                (org-delete-char -1)))
                          (unless (eq arg 0) (delete-char (1+ (- arg)))
                                  (org-delete-char -1))))))
           (let ((pt (point)))
             (if (not (eq 0 (skip-syntax-backward "\\s-")))
                 (delete-region (point) pt)
               (unless (eq arg 0) (delete-char (1+ (- arg)))
                       (org-delete-char -1)))))
         (when (equal (buffer-substring-no-properties (point-at-bol)
                                                      (point))
                      ":END:")
           (let ((s (buffer-substring-no-properties (point) (point-at-eol))))
             (delete-region (point) (point-at-eol))
             (re-search-backward org-property-start-re)
             (lattie--skip-backwards-past-deadline)
             (forward-char -1)
             (insert s)
             (forward-char (- (length s))))))
        (t (let ((pt (point)))
             (if (not (eq 0 (skip-syntax-backward "\\s-" (point-at-bol 0))))
                 (delete-region (point) pt)
               (unless (eq arg 0) (delete-char (1+ (- arg)))
                       (delete-char -1)))))))

(defun lattie-flow ()
  (cond ((lattie--right-p)
         (cond ((string-prefix-p "\\begin{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                (while (looking-at (concat "\\(\\s-*\\)" lattie-opening-environment-regexp-for-looking-at))
                  (delete-region (match-beginning 1) (match-end 1))
                  (insert-char ?\n)
                  (forward-char (- (match-end 0) (match-end 1))))
                (delete-region (point) (progn (skip-syntax-forward "\\s-") (point)))
                (insert-char ?\n 2)
                (forward-char -1))
               ((string-prefix-p "\\end{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                (while (looking-back (concat lattie-closing-environment-regexp "\\s-*") (point-at-bol -1))
                  (re-search-backward lattie-closing-environment-regexp (point-at-bol -1) t)
                  (forward-char 1)
                  (delete-region (min (point)
                                      (progn (skip-chars-backward "\n")
                                             (+ 2 (point))))
                                 (point))
                  (if (looking-back lattie-opening-environment-regexp-for-looking-at (point-at-bol) t)
                      (progn (insert-char ?\n 2)
                             (forward-char -1))
                    (insert-char ?\n)
                    (forward-char -1))))
               (t (re-search-backward lattie-closing-math-regexp nil t)
                  (forward-char 1))))
        ((lattie--left-p)
         (cond ((string-prefix-p "\\begin{" (substring-no-properties (match-string-no-properties 0) 1 nil))
                ;; (message "left : %s" (match-string-no-properties 0))
                (forward-char (- (match-end 0) (match-beginning 0)))
                (while (looking-at (concat "\\(\\s-+\\)" lattie-opening-environment-regexp-for-looking-at))
                  (delete-region (match-beginning 1) (match-end 1))
                  (insert-char ?\n)
                  (forward-char (- (match-end 0) (match-end 1))))
                (delete-region (point) (progn (skip-syntax-forward "\\s-") (point)))
                (insert-char ?\n 2)
                (forward-char -1))
               (t (re-search-forward lattie-opening-math-regexp nil t))))))

(defun special-lattie-flow (arg)
  (interactive "p")
  (if (lattie--special-p)
      (lattie-flow)
    (lattie-self-insert-command arg)))

(defun special-lattie-newline-and-indent ()
  (interactive)
  ;; (when (lattie--right-p)
  ;;   (org-preview-latex-fragment))
  (cond ((and (org-at-heading-p)
              (not (bolp)))
         (let ((s (buffer-substring-no-properties (point)
                                                  (point-at-eol))))
           (delete-region (point) (point-at-eol))
           (unless (eobp)
             (forward-char 1))
           (when (eq (point) (progn (lattie--skip-past-deadline)
                                    (lattie--skip-past-property-drawer)
                                    (point)))
             (forward-char -1))
           (call-interactively #'org-return-indent)
           (insert s)
           (beginning-of-line)))
        ((lattie--math-shorthand-p)
         (lattie--apply-math-shorthand-before-point)
         (unless (eq (char-before) ?\n)
           (call-interactively #'org-return-indent)))
        (t (call-interactively #'org-return-indent)))
  (when (looking-back "\\]\\s-*")
    (put-text-property (1- (point))
                                  (point)
                                  'font-lock-face
                                  nil)))

(defun special-lattie-forward (arg)
  (interactive "p")
  (if (lattie--special-p)
      (lattie-forward arg)
    (lattie-self-insert-command arg)))

(defun lattie-close-bracket (arg)
  (interactive "p")
  (cond ((and (looking-back "[^\\]\\\\" (1- (point-at-bol)) nil)
              (or (looking-at "\\s-")
                  (eobp)))
         (lattie-self-insert-command arg))
        ((when-let ((context (and (memq major-mode '(org-mode
                                                     org-journal-mode))
                                  (org-element-context))))
           (cond ((and (eq 'headline (car context))
                       (eq (point)
                           (+ (org-element-property :level context)
                              (org-element-property :begin context)
                              1)))
                  (insert "[ ] "))
                 ((and (eq 'item (car context))
                       (eq (point)
                           (+ (org-element-property :begin context)
                              (length (org-element-property :bullet context)))))
                  (insert "[ ] "))
                 (t (lattie-forward-or-eol arg)))))
        (t (lattie-forward-or-eol arg))))

(defun lattie--in-tikzcd-p ()
  (save-excursion
    (let ((limit (lattie--get-forward-limit)))
      (re-search-forward "\\end{tikzcd}" limit t))))

(defun lattie--ar-snipet-delete-empty-string (s)
  (let ((yas-inhibit-overlay-modification-protection t))
    (when (and (not yas-modified-p)
               yas-moving-away-p)
      (delete-region (- (point) 3)
                     (save-excursion (1- (search-forward "]" (point-at-eol) t)))))
    (if (and (s-starts-with? "(" s)
             (s-ends-with? ")" s))
        (s-wrap s "{" "}")
      s)))

(defun lattie-forward-or-eol (arg)
  (if (and (eq (point)
               (progn (lattie-forward arg)
                      (point))))
      (end-of-line)
    ""))

(defun lattie-open-bracket (arg)
  (interactive "p")
  (cond ((looking-back "[^\\]\\\\" (1- (point-at-bol)) nil)
         (insert-char ?\[)
         (insert-char ?\\)
         (insert-char ?\])
         (let ((faces (get-text-property (point) 'face)))
           (put-text-property (- (point) 4)
                              (point)
                              'font-lock-face
                              (cons 'font-latex-math-face faces)))
         (forward-char -2))
        (t (lattie-backward arg))))

(defun special-lattie-dollar ()
  (interactive)
  (let ((lattie--special-p (lattie--special-p)))
    (cond ((and (not lattie--special-p)
                (not (lattie--math-p))
                (eq (char-before) ?\s)
                (eq (char-before (1- (point))) ?$))
           (delete-char -1)
           (forward-char -1)
           (insert "\\,"))
          ((or (and (lattie--math-p)
                    (not lattie--special-p))
               (and (eq (char-after) ?$)
                    (eq (char-before) ?$)))
           (insert-char ?\[)
           (insert-char ?\])
           (forward-char -1))
          (lattie--special-p
           (if (memq major-mode '(org-mode org-journal-mode))
               (org-end-of-line)
             (end-of-line)))
          (t (cdlatex-dollar)
             (let ((faces (get-text-property (point) 'face)))
               (put-text-property (1- (point))
                                  (1+ (point))
                                  'font-lock-face
                                  (cons 'font-latex-math-face faces)))))))

(defun special-lattie-back-to-heading ()
  (interactive)
  (cond ((and (lattie--math-p)
              (not (lattie--special-p)))
         (org-cdlatex-underscore-caret))
        ((org-at-heading-p)
         (org-up-element))
        (t (org-back-to-heading)
           (beginning-of-line))))

(defun lattie-insert-dollar ()
  (interactive)
  (if (lattie--math-p)
      (insert "\\plus")
    (org-self-insert-command 1)))

(defun special-lattie-open-brace ()
  (interactive)
  (cond ((lattie--math-shorthand-p)
         (if (eq (char-before) ?`)
             (insert "{")
           (insert "{}")
           (forward-char -1)))
        ((looking-back "\\\\\\w*\\|[\\^\_]\\|\}" (point-at-bol) nil)
         (lattie-self-insert-command 1))
        ((search-backward "{" (point-at-bol) t)
         (forward-char 1)
         (push-mark (match-end 0) t t)
         (search-forward-regexp "\\\\\\{0,2\\}\}" (point-at-eol) t)
         (goto-char (match-beginning 0))
         (delete-selection-mode 0))))

(defun special-lattie-close-brace ()
  (interactive)
  (cond ((looking-at "\\\\\\{1,2\\}\}")
         (goto-char (match-end 0))
         (deactivate-mark))
        ;; ((eq (char-after) ?\])
        ;;  (forward-char 1))
        ((looking-at "[\)\}]+")
         (skip-chars-forward "\)\]\}"))
        ((lattie--math-p)
         (if (nth 3 (syntax-ppss))
             (progn (insert "{}")
                    (forward-char -1))
           (insert "\\{\\}")
           (forward-char -2)))
        (t (lattie-self-insert-command 1))))

(defun lattie-open-paren ()
  (interactive)
  (if (lattie--math-p)
      (progn (insert "()")
             (forward-char -1))
    (lattie-self-insert-command 1)))

(defun special-lattie-tab ()
  (interactive)
  (if (or (lattie--math-p)
          (lattie--math-shorthand-p))
      (cdlatex-tab)
    (org-cycle)))

;;; Non-TeX tricks
(defun lattieville-table-previous-row-or-eol ()
  (interactive)
  (if (org-at-table-p)
      (call-interactively #'+org/table-previous-row)
    (call-interactively #'org-end-of-line)))

(defun lattie-ctrl-ret ()
  (interactive)
  (let ((direction 'below))
    (if (and (org-at-table-p)
             (eq 1 (- (org-table-end)
                      (point))))
        (let* ((context
                (save-excursion
                  (goto-char (org-table-begin))
                  (forward-char -1)
                  (when (bolp)
                    (back-to-indentation)
                    (forward-char))
                  (org-element-lineage
                   (org-element-context)
                   '(table table-row headline inlinetask item plain-list)
                   t)))
               (type (org-element-type context)))
          (cond ((memq type '(item plain-list))
                 (let ((marker (org-element-property :bullet context))
                       (pad (save-excursion
                              (org-beginning-of-item)
                              (back-to-indentation)
                              (- (point) (line-beginning-position)))))
                   (save-match-data
                     (pcase direction
                       (`below
                        (org-end-of-item)
                        (backward-char)
                        (end-of-line)
                        (if (and marker (string-match "\\([0-9]+\\)\\([).] *\\)" marker))
                            (progn (goto-char (plist-get (cadr context) :end))
                                   (let ((l (line-number-at-pos pt)))
                                     (org-insert-item)
                                     (when (= l (line-number-at-pos))
                                       (org-next-item)
                                       (org-end-of-line))))
                          (insert "\n" (make-string pad 32) (or marker ""))))
                       (`above
                        (org-beginning-of-item)
                        (if (and marker (string-match-p "[0-9]+[).]" marker))
                            (org-insert-item)
                          (insert (make-string pad 32) (or marker ""))
                          (save-excursion (insert "\n")))))))
                 (when (org-element-property :checkbox context)
                   (insert "[ ] ")))

                ((memq type '(table table-row))
                 (pcase direction
                   ('below (save-excursion (org-table-insert-row t))
                           (org-table-next-row))
                   ('above (save-excursion (org-shiftmetadown))
                           (+org/table-previous-row))))

                ((memq type '(headline inlinetask))
                 (let ((level (if (eq (org-element-type context) 'headline)
                                  (org-element-property :level context)
                                1)))
                   (pcase direction
                     (`below
                      (let ((at-eol (>= (point) (1- (line-end-position))))
                            org-insert-heading-respect-content)
                        (ignore org-insert-heading-respect-content)
                        (goto-char (line-end-position))
                        (org-end-of-subtree)
                        (insert (concat "\n"
                                        (when (= level 1)
                                          (if at-eol
                                              (ignore (cl-incf level))
                                            "\n"))
                                        (make-string level ?*)
                                        " "))))
                     (`above
                      (org-back-to-heading)
                      (insert (make-string level ?*) " ")
                      (save-excursion
                        (insert "\n")
                        (if (= level 1) (insert "\n")))))
                   (when-let* ((todo-keyword (org-element-property :todo-keyword context)))
                     (org-todo (or (car (+org-get-todo-keywords-for todo-keyword))
                                   'todo)))))

                (t (user-error "Not a valid list, heading or table")))
          (when (org-invisible-p)
            (org-show-hidden-entry)))
      (+org-insert-item 'below))))

(defun special-lattie-space ()
  (interactive)
  (cond ((or (and (eq (char-before) ?$)
                  (not (lattie--at-right-side-of-closing-expression?)))
             (eq (char-before) ?,)
             ;; Inside sexp?
             (second (syntax-ppss))
             (not (lattie--math-shorthand-p)))
         (if (and (eq (char-after) ?$)
                  (not (lattie--at-left-side-of-opening-expression?)))
             (let ((faces (get-text-property (point) 'face)))
               (lattie-self-insert-command 1)
               (put-text-property (save-excursion (1+ (re-search-backward lattie-dollar-regexp nil t)))
                                  (1+ (point))
                                  'font-lock-face
                                  '(font-latex-math-face)))
           (lattie-self-insert-command 1)))
        ((and (eq (char-before) ?\`)
              (lattie--math-shorthand-p))
         (insert (this-command-keys)))
        (t (lattie--apply-math-shorthand-before-point 'self-insert))))

(defun lattie-split-string (string &optional separators omit-nulls keep-sep)
  "Split STRING into substrings bounded by matches for SEPARATORS."
  (let* ((keep-nulls (not (if separators omit-nulls t)))
         (rexp (or separators split-string-default-separators))
         (start 0)
         this-start this-end
         notfirst
         (list nil)
         (push-one
          (lambda ()
            (when (or keep-nulls (< this-start this-end))
              (let ((this (substring string this-start this-end)))
                (when (or keep-nulls (> (length this) 0))
                  (push this list)))))))
    (while (and (string-match
                 rexp string
                 (if (and notfirst
                          (= start (match-beginning 0))
                          (< start (length string)))
                     (1+ start) start))
                (< start (length string)))
      (setq notfirst t)
      (setq this-start start this-end (match-beginning 0)
            start (match-end 0))
      (funcall push-one)
      (when keep-sep
        (push (match-string 0 string) list)))
    (setq this-start start this-end (length string))
    (funcall push-one)
    (nreverse list)))

(defun lattie--apply-math-shorthand-before-point (&optional self-insert-p)
  (let* ((s (buffer-substring-no-properties (+ (match-beginning 0) 2)
                                            (match-end 0)))
         (op (if (s-prefix-p "," s)
                 (if (eq (char-after (match-beginning 0))
                         ?\n)
                     "\\["
                   "\n\\[")
               "$"))
         (cl (if (equal op "$")
                 "$"
               "\\]\n")))
    (delete-region (1+ (match-beginning 0)) (match-end 0))
    (when (s-prefix-p "," s)
      (setq s (substring-no-properties s 1)))
    (put-text-property (point)
                       (progn (insert op
                                      (lattie--expand-math-apply s)
                                      (if (or (equal op "$")
                                              (not self-insert-p)
                                              (equal (aref (this-command-keys-vector) 0)
                                                     ?\s))
                                          ""
                                        (this-command-keys))
                                      cl)
                              (1- (point)))
                       'font-lock-face
                       (list 'font-latex-math-face))
    (when (and self-insert-p
               (equal op "$"))
      (lattie-self-insert-command 1))
    (put-text-property (1- (point))
                                  (point)
                                  'font-lock-face
                                  nil)))

(defun lattie--math-shorthand-p ()
  (looking-back "[\t\s\n],[-a-zA-Z0-9.,_^&*@!#%(){}'`|+<>=:]*" (1- (point-at-bol)) t))

;; (progn (lattie--math-shorthand-p)
;;        (lattie--apply-math-shorthand-before-point))

(defvar lattie-arrows)
(setq lattie-arrows
      '((">->" . "\\hookrightarrow")
        ("->" . "\\rightarrow")
        (">=" . "\\geq")
        ("<=" . "\\leq")
        ("|->" . "\\mapsto")
        ))

(defun lattie--arrow-regexp ()
  (->> lattie-arrows
     (-map #'car)
     (-map #'regexp-quote)
     (s-join "\\|")))

(defun lattie--expand-math-apply (s)
  (->> (lattie-split-string
      s
      (concat (lattie--arrow-regexp)
              "\\|`+.\\|[a-zA-Z0-9]'+.\\|"
              "\\([_^] *\\([^\n\\{}]\\|\
\\\\\\([a-zA-Z@]+\\|[^ \t\n]\\)\\|\\({\\)\\)\\)"
              "\\|[^a-zA-Z0-9\\]")
      t t)
     (-map #'lattie--expand-math)
     (s-join " ")
     (s-replace " : " ": ")
     (s-replace " _ " "_")
     (s-replace " ^ " "^")
     (s-replace "( " "(")
     (s-replace " (" "(")
     (s-replace " )" ")")
     ;; (s-replace "{ " "\\{")
     ;; (s-replace "{ " "{")
     ;; (s-replace " }" "}")
     ;; TODO This does not work with nested braces like {0, {0 , 1}}
     (replace-regexp-in-string "\\(?: \\|^\\){ \\([^{}]+\\) }\\(?: \\|$\\)"
                               "\\\\{\\1\\\\}")
     (s-replace "{ " "{")
     (s-replace " }" "}")
     ;; (s-replace " }" "\\}")
     (s-replace " ," ",")
     (s-replace " _" "_")
     (s-replace " ^" "^")
     (s-replace " \\prime" "\\prime")))

(defun lattie--grave-shorthand (s)
  (eq (aref s 0) ?\`))

(defun lattie-yas-next-field-or-maybe-expand (oldfun &rest args)
  (interactive)
  (and (memq major-mode '(org-mode org-journal-mode))
       (lattie--math-p)
       (if (eq (char-after) ?})
           (call-interactively #'org-try-cdlatex-tab)
         (apply oldfun args))))

(advice-add #'yas-next-field-or-maybe-expand
            :around
            #'lattie-yas-next-field-or-maybe-expand)

(defun lattie--quote-shorthand (s)
  (and (>= (length s) 3)
       (eq (aref s 1) ?\')))

(defun lattie--arrow-p (s)
  (alist-get s lattie-arrows
             nil nil #'equal))

;; (lattie--expand-math-apply "a``dB")

(defun lattie--expand-math (s)
  (pcase s
    ("+" "\\plus")
    ((pred lattie--arrow-p)
     (alist-get s lattie-arrows
                nil nil
                #'equal))
    ((pred lattie--grave-shorthand)
     (nth (1- (length s)) (assoc (aref s (1- (length s))) cdlatex-math-symbol-alist-comb)))
    ((pred lattie--quote-shorthand)
     (let* ((mathcmd-with-rules (assoc (aref s (1- (length s))) cdlatex-math-modify-alist-comb))
            (mathcmd (nth 1 mathcmd-with-rules))
            (type (nth 3 mathcmd-with-rules)))
       (if type
           (concat mathcmd "{" (char-to-string (aref s 0)) "}")
         (concat "{" mathcmd " " (char-to-string (aref s 0)) "}"))))
    (_ (or (abbrev-expansion s)
           s))))

;; (lattie--expand-math "a")

;; (lattie--expand-math-apply "a<=b")

(defun special-lattie-punctuation ()
  (interactive)
  (if (and (eq (char-after) ?$)
           (not (lattie--at-left-side-of-opening-expression?)))
      (unless (and (eq (char-before) ?$)
                   (not (lattie--at-right-side-of-closing-expression?)))
        (when (looking-back "[\s\t\n],[a-zA-Z0-9,]+" (point-at-bol) nil)
          (insert "$"
                  (buffer-substring (+ (match-beginning 0) 2)
                                    (match-end 0))
                  "$")
          (delete-region (1+ (match-beginning 0)) (match-end 0))))
    (if (and (eq (char-before) ?$)
             (lattie--at-right-side-of-closing-expression?))
        (progn (lattie-self-insert-command 1)
               (put-text-property (1- (point))
                                  (point)
                                  'font-lock-face
                                  nil))
      (lattie-self-insert-command 1))))

;; (defun special-lattie-minus ()
;;   (interactive)
;;   (when (looking-back ",[a-zA-Z0-9]+" (point-at-bol) nil)
;;     (insert "$"
;;             (buffer-substring (1+ (match-beginning 0)) (match-end 0))
;;             "$")
;;     (delete-region (match-beginning 0) (match-end 0)))
;;   (if (fboundp 'typo-cycle-dashes)
;;       (typo-cycle-dashes 1)
;;     (lattie-self-insert-command 1)))

(defun special-lattie-toggle-latex-fragment ()
  (interactive)
  (if (lattie--special-p)
      (org-toggle-latex-fragment)
    (lattie-self-insert-command 1)))

(defun special-lattie-digit ()
  (interactive)
  (if (or (lattie--special-p)
          ;; (and (eq major-mode 'org-mode)
          ;;      (org-at-heading-or-item-p))
          )
      (call-interactively #'digit-argument)
    (lattie-self-insert-command 1)))

(defun special-lattie-digit-or-bol (arg)
  (interactive "P")
  (if (or (lattie--special-p)
          ;; (and (eq major-mode 'org-mode)
          ;;      (org-at-heading-or-item-p))
          )
      (if arg
          (call-interactively #'digit-argument)
        (if (eq major-mode '(org-mode org-journal-mode))
            (org-beginning-of-line)
          (back-to-indentation)))
    (lattie-self-insert-command (or arg 1))))

(defun special-lattie-compile ()
  (interactive)
  (if (lattie--special-p)
      (ignore-errors (org-export-dispatch))
    (lattie-self-insert-command 1)))

;; (map! :map evil-org-mode-map
;;       "<return>" #'special-lattie-newline-and-indent
;;       [tab] #'org-cycle
;;       [C-return] #'lattie-ctrl-ret
;;       "C-n" #'org-table-next-row
;;       "C-e" #'lattieville-table-previous-row-or-eol
;;       "C-i" #'org-table-next-field
;;       "C-m" #'org-table-previous-field
;;       "C-j" nil
;;       "C-k" nil
;;       "C-l" nil
;;       "C-h" nil)

(provide 'lattie)


;; Local Variables:
;; eval: (add-hook! 'after-save-hook :local (byte-compile-file (buffer-file-name (current-buffer)) t))
;; End:
